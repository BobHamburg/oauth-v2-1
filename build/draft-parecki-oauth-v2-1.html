<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>The OAuth 2.1 Authorization Framework</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Roles">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Protocol Flow">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Authorization Grant">
<link href="#rfc.section.1.3.1" rel="Chapter" title="1.3.1 Authorization Code">
<link href="#rfc.section.1.3.2" rel="Chapter" title="1.3.2 Client Credentials">
<link href="#rfc.section.1.4" rel="Chapter" title="1.4 Access Token">
<link href="#rfc.section.1.5" rel="Chapter" title="1.5 Refresh Token">
<link href="#rfc.section.1.6" rel="Chapter" title="1.6 TLS Version">
<link href="#rfc.section.1.7" rel="Chapter" title="1.7 HTTP Redirections">
<link href="#rfc.section.1.8" rel="Chapter" title="1.8 Interoperability">
<link href="#rfc.section.1.9" rel="Chapter" title="1.9 Notational Conventions">
<link href="#rfc.section.2" rel="Chapter" title="2 Client Registration">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Client Types">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Client Identifier">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Client Authentication">
<link href="#rfc.section.2.3.1" rel="Chapter" title="2.3.1 Client Password">
<link href="#rfc.section.2.3.2" rel="Chapter" title="2.3.2 Other Authorization Methods">
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Unregistered Clients">
<link href="#rfc.section.3" rel="Chapter" title="3 Protocol Endpoints">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Authorization Endpoint">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Response Type">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Redirection Endpoint">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Token Endpoint">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Client Authentication">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Access Token Scope">
<link href="#rfc.section.4" rel="Chapter" title="4 Obtaining Authorization">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Authorization Code Grant">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Authorization Request">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Authorization Response">
<link href="#rfc.section.4.1.3" rel="Chapter" title="4.1.3 Access Token Request">
<link href="#rfc.section.4.1.4" rel="Chapter" title="4.1.4 Access Token Response">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Client Credentials Grant">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Authorization Request and Response">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Access Token Request">
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 Access Token Response">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Extension Grants">
<link href="#rfc.section.5" rel="Chapter" title="5 Issuing an Access Token">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Successful Response">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Error Response">
<link href="#rfc.section.6" rel="Chapter" title="6 Refreshing an Access Token">
<link href="#rfc.section.7" rel="Chapter" title="7 Accessing Protected Resources">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Access Token Types">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Bearer Tokens">
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Authenticated Requests">
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 The WWW-Authenticate Response Header Field">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Error Response">
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 Error Codes">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Access Token Security Considerations">
<link href="#rfc.section.7.4.1" rel="Chapter" title="7.4.1 Security Threats">
<link href="#rfc.section.7.4.2" rel="Chapter" title="7.4.2 Threat Mitigation">
<link href="#rfc.section.7.4.3" rel="Chapter" title="7.4.3 Summary of Recommendations">
<link href="#rfc.section.7.4.4" rel="Chapter" title="7.4.4 Token Replay Prevention">
<link href="#rfc.section.7.4.5" rel="Chapter" title="7.4.5 Access Token Privilege Restriction">
<link href="#rfc.section.8" rel="Chapter" title="8 Extensibility">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Defining Access Token Types">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Defining New Endpoint Parameters">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Defining New Authorization Grant Types">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 Defining New Authorization Endpoint Response Types">
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 Defining Additional Error Codes">
<link href="#rfc.section.9" rel="Chapter" title="9 Native Applications">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Authorization Flow for Native Apps Using the Browser">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Using Inter-App URI Communication for OAuth in Native Apps">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Initiating the Authorization Request from a Native App">
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Receiving the Authorization Response in a Native App">
<link href="#rfc.section.9.4.1" rel="Chapter" title="9.4.1 Private-Use URI Scheme Redirection">
<link href="#rfc.section.9.4.2" rel="Chapter" title='9.4.2 Claimed "https" Scheme URI Redirection'>
<link href="#rfc.section.9.4.3" rel="Chapter" title="9.4.3 Loopback Interface Redirection">
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Client Authentication">
<link href="#rfc.section.10.1.1" rel="Chapter" title="10.1.1 Client Authentication of Native Apps">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Registration of Native App Clients">
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Client Impersonation">
<link href="#rfc.section.10.3.1" rel="Chapter" title="10.3.1 Impersonation of Native Apps">
<link href="#rfc.section.10.4" rel="Chapter" title="10.4 Access Tokens">
<link href="#rfc.section.10.4.1" rel="Chapter" title="10.4.1 Access Token Privilege Restriction">
<link href="#rfc.section.10.4.2" rel="Chapter" title="10.4.2 Access Token Replay Prevention">
<link href="#rfc.section.10.5" rel="Chapter" title="10.5 Refresh Tokens">
<link href="#rfc.section.10.6" rel="Chapter" title="10.6 Protecting Redirect-Based Flows">
<link href="#rfc.section.10.6.1" rel="Chapter" title="10.6.1 Loopback Redirect Considerations in Native Apps">
<link href="#rfc.section.10.7" rel="Chapter" title="10.7 Authorization Codes">
<link href="#rfc.section.10.8" rel="Chapter" title="10.8 Request Confidentiality">
<link href="#rfc.section.10.9" rel="Chapter" title="10.9 Ensuring Endpoint Authenticity">
<link href="#rfc.section.10.10" rel="Chapter" title="10.10 Credentials-Guessing Attacks">
<link href="#rfc.section.10.11" rel="Chapter" title="10.11 Phishing Attacks">
<link href="#rfc.section.10.12" rel="Chapter" title="10.12 Fake External User-Agents in Native Apps">
<link href="#rfc.section.10.13" rel="Chapter" title="10.13 Malicious External User-Agents in Native Apps">
<link href="#rfc.section.10.14" rel="Chapter" title="10.14 Cross-Site Request Forgery">
<link href="#rfc.section.10.15" rel="Chapter" title="10.15 Clickjacking">
<link href="#rfc.section.10.16" rel="Chapter" title="10.16 Code Injection and Input Validation">
<link href="#rfc.section.10.17" rel="Chapter" title="10.17 Open Redirectors">
<link href="#rfc.section.10.17.1" rel="Chapter" title="10.17.1 Client as Open Redirector">
<link href="#rfc.section.10.17.2" rel="Chapter" title="10.17.2 Authorization Server as Open Redirector">
<link href="#rfc.section.10.18" rel="Chapter" title="10.18 Authorization Server Mix-Up Mitigation in Native Apps">
<link href="#rfc.section.10.19" rel="Chapter" title="10.19 Embedded User Agents in Native Apps">
<link href="#rfc.section.10.20" rel="Chapter" title="10.20 Other Recommendations">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 OAuth Access Token Types Registry">
<link href="#rfc.section.11.1.1" rel="Chapter" title="11.1.1 Registration Template">
<link href="#rfc.section.11.1.2" rel="Chapter" title="11.1.2 Initial Registry Contents">
<link href="#rfc.section.11.2" rel="Chapter" title="11.2 OAuth Parameters Registry">
<link href="#rfc.section.11.2.1" rel="Chapter" title="11.2.1 Registration Template">
<link href="#rfc.section.11.2.2" rel="Chapter" title="11.2.2 Initial Registry Contents">
<link href="#rfc.section.11.3" rel="Chapter" title="11.3 OAuth Authorization Endpoint Response Types Registry">
<link href="#rfc.section.11.3.1" rel="Chapter" title="11.3.1 Registration Template">
<link href="#rfc.section.11.3.2" rel="Chapter" title="11.3.2 Initial Registry Contents">
<link href="#rfc.section.11.4" rel="Chapter" title="11.4 OAuth Extensions Error Registry">
<link href="#rfc.section.11.4.1" rel="Chapter" title="11.4.1 Registration Template">
<link href="#rfc.section.11.4.2" rel="Chapter" title="11.4.2 Initial Registry Contents">
<link href="#rfc.references" rel="Chapter" title="12 References">
<link href="#rfc.references.1" rel="Chapter" title="12.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="12.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Augmented Backus-Naur Form (ABNF) Syntax">
<link href="#rfc.appendix.A.1" rel="Chapter" title='A.1 "client_id" Syntax'>
<link href="#rfc.appendix.A.2" rel="Chapter" title='A.2 "client_secret" Syntax'>
<link href="#rfc.appendix.A.3" rel="Chapter" title='A.3 "response_type" Syntax'>
<link href="#rfc.appendix.A.4" rel="Chapter" title='A.4 "scope" Syntax'>
<link href="#rfc.appendix.A.5" rel="Chapter" title='A.5 "state" Syntax'>
<link href="#rfc.appendix.A.6" rel="Chapter" title='A.6 "redirect_uri" Syntax'>
<link href="#rfc.appendix.A.7" rel="Chapter" title='A.7 "error" Syntax'>
<link href="#rfc.appendix.A.8" rel="Chapter" title='A.8 "error_description" Syntax'>
<link href="#rfc.appendix.A.9" rel="Chapter" title='A.9 "error_uri" Syntax'>
<link href="#rfc.appendix.A.10" rel="Chapter" title='A.10 "grant_type" Syntax'>
<link href="#rfc.appendix.A.11" rel="Chapter" title='A.11 "code" Syntax'>
<link href="#rfc.appendix.A.12" rel="Chapter" title='A.12 "access_token" Syntax'>
<link href="#rfc.appendix.A.13" rel="Chapter" title='A.13 "token_type" Syntax'>
<link href="#rfc.appendix.A.14" rel="Chapter" title='A.14 "expires_in" Syntax'>
<link href="#rfc.appendix.A.15" rel="Chapter" title='A.15 "refresh_token" Syntax'>
<link href="#rfc.appendix.A.16" rel="Chapter" title="A.16 Endpoint Parameter Syntax">
<link href="#rfc.appendix.A.17" rel="Chapter" title='A.17 "code_verifier" Syntax'>
<link href="#rfc.appendix.A.18" rel="Chapter" title='A.18 "code_challenge" Syntax'>
<link href="#rfc.appendix.B" rel="Chapter" title="B Use of application/x-www-form-urlencoded Media Type">
<link href="#rfc.appendix.C" rel="Chapter" title="C Acknowledgements">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.40.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Parecki, A., Hardt, D., and T. Lodderstedt" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-parecki-oauth-v2-1-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2020-03-04" />
  <meta name="dct.abstract" content="The OAuth 2.1 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf.  This specification replaces and obsoletes the OAuth 2.0 Authorization Framework described in RFC 6749. " />
  <meta name="description" content="The OAuth 2.1 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf.  This specification replaces and obsoletes the OAuth 2.0 Authorization Framework described in RFC 6749. " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">A. Parecki</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right"></td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">D. Hardt</td>
</tr>
<tr>
<td class="left">Expires: September 5, 2020</td>
<td class="right"></td>
</tr>
<tr>
<td class="left"></td>
<td class="right">T. Lodderstedt</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">March 04, 2020</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">The OAuth 2.1 Authorization Framework<br />
  <span class="filename">draft-parecki-oauth-v2-1-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The OAuth 2.1 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf.  This specification replaces and obsoletes the OAuth 2.0 Authorization Framework described in RFC 6749.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 5, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2020 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Roles</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Protocol Flow</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Authorization Grant</a>
</li>
<ul><li>1.3.1.   <a href="#rfc.section.1.3.1">Authorization Code</a>
</li>
<li>1.3.2.   <a href="#rfc.section.1.3.2">Client Credentials</a>
</li>
</ul><li>1.4.   <a href="#rfc.section.1.4">Access Token</a>
</li>
<li>1.5.   <a href="#rfc.section.1.5">Refresh Token</a>
</li>
<li>1.6.   <a href="#rfc.section.1.6">TLS Version</a>
</li>
<li>1.7.   <a href="#rfc.section.1.7">HTTP Redirections</a>
</li>
<li>1.8.   <a href="#rfc.section.1.8">Interoperability</a>
</li>
<li>1.9.   <a href="#rfc.section.1.9">Notational Conventions</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Client Registration</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Client Types</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Client Identifier</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Client Authentication</a>
</li>
<ul><li>2.3.1.   <a href="#rfc.section.2.3.1">Client Password</a>
</li>
<li>2.3.2.   <a href="#rfc.section.2.3.2">Other Authorization Methods</a>
</li>
</ul><li>2.4.   <a href="#rfc.section.2.4">Unregistered Clients</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Protocol Endpoints</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Authorization Endpoint</a>
</li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">Response Type</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Redirection Endpoint</a>
</li>
</ul><li>3.2.   <a href="#rfc.section.3.2">Token Endpoint</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">Client Authentication</a>
</li>
</ul><li>3.3.   <a href="#rfc.section.3.3">Access Token Scope</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Obtaining Authorization</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Authorization Code Grant</a>
</li>
<ul><li>4.1.1.   <a href="#rfc.section.4.1.1">Authorization Request</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">Authorization Response</a>
</li>
<li>4.1.3.   <a href="#rfc.section.4.1.3">Access Token Request</a>
</li>
<li>4.1.4.   <a href="#rfc.section.4.1.4">Access Token Response</a>
</li>
</ul><li>4.2.   <a href="#rfc.section.4.2">Client Credentials Grant</a>
</li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">Authorization Request and Response</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Access Token Request</a>
</li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">Access Token Response</a>
</li>
</ul><li>4.3.   <a href="#rfc.section.4.3">Extension Grants</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Issuing an Access Token</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Successful Response</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Error Response</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Refreshing an Access Token</a>
</li>
<li>7.   <a href="#rfc.section.7">Accessing Protected Resources</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Access Token Types</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Bearer Tokens</a>
</li>
<ul><li>7.2.1.   <a href="#rfc.section.7.2.1">Authenticated Requests</a>
</li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">The WWW-Authenticate Response Header Field</a>
</li>
</ul><li>7.3.   <a href="#rfc.section.7.3">Error Response</a>
</li>
<ul><li>7.3.1.   <a href="#rfc.section.7.3.1">Error Codes</a>
</li>
</ul><li>7.4.   <a href="#rfc.section.7.4">Access Token Security Considerations</a>
</li>
<ul><li>7.4.1.   <a href="#rfc.section.7.4.1">Security Threats</a>
</li>
<li>7.4.2.   <a href="#rfc.section.7.4.2">Threat Mitigation</a>
</li>
<li>7.4.3.   <a href="#rfc.section.7.4.3">Summary of Recommendations</a>
</li>
<li>7.4.4.   <a href="#rfc.section.7.4.4">Token Replay Prevention</a>
</li>
<li>7.4.5.   <a href="#rfc.section.7.4.5">Access Token Privilege Restriction</a>
</li>
</ul></ul><li>8.   <a href="#rfc.section.8">Extensibility</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Defining Access Token Types</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Defining New Endpoint Parameters</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">Defining New Authorization Grant Types</a>
</li>
<li>8.4.   <a href="#rfc.section.8.4">Defining New Authorization Endpoint Response Types</a>
</li>
<li>8.5.   <a href="#rfc.section.8.5">Defining Additional Error Codes</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Native Applications</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Authorization Flow for Native Apps Using the Browser</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Using Inter-App URI Communication for OAuth in Native Apps</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Initiating the Authorization Request from a Native App</a>
</li>
<li>9.4.   <a href="#rfc.section.9.4">Receiving the Authorization Response in a Native App</a>
</li>
<ul><li>9.4.1.   <a href="#rfc.section.9.4.1">Private-Use URI Scheme Redirection</a>
</li>
<li>9.4.2.   <a href="#rfc.section.9.4.2">Claimed "https" Scheme URI Redirection</a>
</li>
<li>9.4.3.   <a href="#rfc.section.9.4.3">Loopback Interface Redirection</a>
</li>
</ul></ul><li>10.   <a href="#rfc.section.10">Security Considerations</a>
</li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Client Authentication</a>
</li>
<ul><li>10.1.1.   <a href="#rfc.section.10.1.1">Client Authentication of Native Apps</a>
</li>
</ul><li>10.2.   <a href="#rfc.section.10.2">Registration of Native App Clients</a>
</li>
<li>10.3.   <a href="#rfc.section.10.3">Client Impersonation</a>
</li>
<ul><li>10.3.1.   <a href="#rfc.section.10.3.1">Impersonation of Native Apps</a>
</li>
</ul><li>10.4.   <a href="#rfc.section.10.4">Access Tokens</a>
</li>
<ul><li>10.4.1.   <a href="#rfc.section.10.4.1">Access Token Privilege Restriction</a>
</li>
<li>10.4.2.   <a href="#rfc.section.10.4.2">Access Token Replay Prevention</a>
</li>
</ul><li>10.5.   <a href="#rfc.section.10.5">Refresh Tokens</a>
</li>
<li>10.6.   <a href="#rfc.section.10.6">Protecting Redirect-Based Flows</a>
</li>
<ul><li>10.6.1.   <a href="#rfc.section.10.6.1">Loopback Redirect Considerations in Native Apps</a>
</li>
</ul><li>10.7.   <a href="#rfc.section.10.7">Authorization Codes</a>
</li>
<li>10.8.   <a href="#rfc.section.10.8">Request Confidentiality</a>
</li>
<li>10.9.   <a href="#rfc.section.10.9">Ensuring Endpoint Authenticity</a>
</li>
<li>10.10.   <a href="#rfc.section.10.10">Credentials-Guessing Attacks</a>
</li>
<li>10.11.   <a href="#rfc.section.10.11">Phishing Attacks</a>
</li>
<li>10.12.   <a href="#rfc.section.10.12">Fake External User-Agents in Native Apps</a>
</li>
<li>10.13.   <a href="#rfc.section.10.13">Malicious External User-Agents in Native Apps</a>
</li>
<li>10.14.   <a href="#rfc.section.10.14">Cross-Site Request Forgery</a>
</li>
<li>10.15.   <a href="#rfc.section.10.15">Clickjacking</a>
</li>
<li>10.16.   <a href="#rfc.section.10.16">Code Injection and Input Validation</a>
</li>
<li>10.17.   <a href="#rfc.section.10.17">Open Redirectors</a>
</li>
<ul><li>10.17.1.   <a href="#rfc.section.10.17.1">Client as Open Redirector</a>
</li>
<li>10.17.2.   <a href="#rfc.section.10.17.2">Authorization Server as Open Redirector</a>
</li>
</ul><li>10.18.   <a href="#rfc.section.10.18">Authorization Server Mix-Up Mitigation in Native Apps</a>
</li>
<li>10.19.   <a href="#rfc.section.10.19">Embedded User Agents in Native Apps</a>
</li>
<li>10.20.   <a href="#rfc.section.10.20">Other Recommendations</a>
</li>
</ul><li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<ul><li>11.1.   <a href="#rfc.section.11.1">OAuth Access Token Types Registry</a>
</li>
<ul><li>11.1.1.   <a href="#rfc.section.11.1.1">Registration Template</a>
</li>
<li>11.1.2.   <a href="#rfc.section.11.1.2">Initial Registry Contents</a>
</li>
</ul><li>11.2.   <a href="#rfc.section.11.2">OAuth Parameters Registry</a>
</li>
<ul><li>11.2.1.   <a href="#rfc.section.11.2.1">Registration Template</a>
</li>
<li>11.2.2.   <a href="#rfc.section.11.2.2">Initial Registry Contents</a>
</li>
</ul><li>11.3.   <a href="#rfc.section.11.3">OAuth Authorization Endpoint Response Types Registry</a>
</li>
<ul><li>11.3.1.   <a href="#rfc.section.11.3.1">Registration Template</a>
</li>
<li>11.3.2.   <a href="#rfc.section.11.3.2">Initial Registry Contents</a>
</li>
</ul><li>11.4.   <a href="#rfc.section.11.4">OAuth Extensions Error Registry</a>
</li>
<ul><li>11.4.1.   <a href="#rfc.section.11.4.1">Registration Template</a>
</li>
<li>11.4.2.   <a href="#rfc.section.11.4.2">Initial Registry Contents</a>
</li>
</ul></ul><li>12.   <a href="#rfc.references">References</a>
</li>
<ul><li>12.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>12.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Augmented Backus-Naur Form (ABNF) Syntax</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">"client_id" Syntax</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">"client_secret" Syntax</a>
</li>
<li>A.3.   <a href="#rfc.appendix.A.3">"response_type" Syntax</a>
</li>
<li>A.4.   <a href="#rfc.appendix.A.4">"scope" Syntax</a>
</li>
<li>A.5.   <a href="#rfc.appendix.A.5">"state" Syntax</a>
</li>
<li>A.6.   <a href="#rfc.appendix.A.6">"redirect_uri" Syntax</a>
</li>
<li>A.7.   <a href="#rfc.appendix.A.7">"error" Syntax</a>
</li>
<li>A.8.   <a href="#rfc.appendix.A.8">"error_description" Syntax</a>
</li>
<li>A.9.   <a href="#rfc.appendix.A.9">"error_uri" Syntax</a>
</li>
<li>A.10.   <a href="#rfc.appendix.A.10">"grant_type" Syntax</a>
</li>
<li>A.11.   <a href="#rfc.appendix.A.11">"code" Syntax</a>
</li>
<li>A.12.   <a href="#rfc.appendix.A.12">"access_token" Syntax</a>
</li>
<li>A.13.   <a href="#rfc.appendix.A.13">"token_type" Syntax</a>
</li>
<li>A.14.   <a href="#rfc.appendix.A.14">"expires_in" Syntax</a>
</li>
<li>A.15.   <a href="#rfc.appendix.A.15">"refresh_token" Syntax</a>
</li>
<li>A.16.   <a href="#rfc.appendix.A.16">Endpoint Parameter Syntax</a>
</li>
<li>A.17.   <a href="#rfc.appendix.A.17">"code_verifier" Syntax</a>
</li>
<li>A.18.   <a href="#rfc.appendix.A.18">"code_challenge" Syntax</a>
</li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">Use of application/x-www-form-urlencoded Media Type</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Acknowledgements</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">In the traditional client-server authentication model, the client requests an access-restricted resource (protected resource) on the server by authenticating with the server using the resource owner's credentials.  In order to provide third-party applications access to restricted resources, the resource owner shares its credentials with the third party.  This creates several problems and limitations:</p>
<p></p>

<ul>
<li>Third-party applications are required to store the resource owner's credentials for future use, typically a password in clear-text.</li>
<li>Servers are required to support password authentication, despite the security weaknesses inherent in passwords.</li>
<li>Third-party applications gain overly broad access to the resource owner's protected resources, leaving resource owners without any ability to restrict duration or access to a limited subset of resources.</li>
<li>Resource owners cannot revoke access to an individual third party without revoking access to all third parties, and must do so by changing the third party's password.</li>
<li>Compromise of any third-party application results in compromise of the end-user's password and all of the data protected by that password.</li>
</ul>
<p id="rfc.section.1.p.3">OAuth addresses these issues by introducing an authorization layer and separating the role of the client from that of the resource owner.  In OAuth, the client requests access to resources controlled by the resource owner and hosted by the resource server, and is issued a different set of credentials than those of the resource owner.</p>
<p id="rfc.section.1.p.4">Instead of using the resource owner's credentials to access protected resources, the client obtains an access token &#8211; a string denoting a specific scope, lifetime, and other access attributes.  Access tokens are issued to third-party clients by an authorization server with the approval of the resource owner.  The client uses the access token to access the protected resources hosted by the resource server.</p>
<p id="rfc.section.1.p.5">For example, an end-user (resource owner) can grant a printing service (client) access to her protected photos stored at a photo- sharing service (resource server), without sharing her username and password with the printing service.  Instead, she authenticates directly with a server trusted by the photo-sharing service (authorization server), which issues the printing service delegation- specific credentials (access token).</p>
<p id="rfc.section.1.p.6">This specification is designed for use with HTTP (<a href="#RFC2616" class="xref">[RFC2616]</a>).  The use of OAuth over any protocol other than HTTP is out of scope.</p>
<p id="rfc.section.1.p.7">Since the publication of the OAuth 2.0 Authorization Framework (<a href="#RFC6749" class="xref">[RFC6749]</a>) in October 2012, it has been updated by OAuth 2.0 for Native Apps (<a href="#RFC8252" class="xref">[RFC8252]</a>), OAuth Security Best Current Practice (<a href="#I-D.ietf-oauth-security-topics" class="xref">[I-D.ietf-oauth-security-topics]</a>), and OAuth 2.0 for Browser-Based Apps (<a href="#I-D.ietf-oauth-browser-based-apps" class="xref">[I-D.ietf-oauth-browser-based-apps]</a>).  The OAuth 2.0 Authorization Framework: Bearer Token Usage (<a href="#RFC6750" class="xref">[RFC6750]</a>) has also been updated with (<a href="#I-D.ietf-oauth-security-topics" class="xref">[I-D.ietf-oauth-security-topics]</a>). This Standards Track specification consolidates the information in all of these documents and removes features that have been found to be insecure in <a href="#I-D.ietf-oauth-security-topics" class="xref">[I-D.ietf-oauth-security-topics]</a>.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#roles" id="roles">Roles</a>
</h1>
<p id="rfc.section.1.1.p.1">OAuth defines four roles:</p>
<p></p>

<dl>
<dt>"resource owner":</dt>
<dd style="margin-left: 8">An entity capable of granting access to a protected resource.  When the resource owner is a person, it is referred to as an end-user.</dd>
<dt>"resource server":</dt>
<dd style="margin-left: 8">The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens.</dd>
<dt>"client":</dt>
<dd style="margin-left: 8">An application making protected resource requests on behalf of the resource owner and with its authorization.  The term "client" does not imply any particular implementation characteristics (e.g., whether the application executes on a server, a desktop, or other devices).</dd>
<dt>"authorization server":</dt>
<dd style="margin-left: 8">The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.</dd>
</dl>
<p id="rfc.section.1.1.p.3">The interaction between the authorization server and resource server is beyond the scope of this specification.  The authorization server may be the same server as the resource server or a separate entity.  A single authorization server may issue access tokens accepted by multiple resource servers.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#protocol-flow" id="protocol-flow">Protocol Flow</a>
</h1>
<div id="rfc.figure.1"></div>
<div id="fig-protocol-flow"></div>
<pre>
     +--------+                               +---------------+
     |        |--(1)- Authorization Request -&gt;|   Resource    |
     |        |                               |     Owner     |
     |        |&lt;-(2)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(3)-- Authorization Grant --&gt;| Authorization |
     | Client |                               |     Server    |
     |        |&lt;-(4)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(5)----- Access Token ------&gt;|    Resource   |
     |        |                               |     Server    |
     |        |&lt;-(6)--- Protected Resource ---|               |
     +--------+                               +---------------+
</pre>
<p class="figure">Figure 1: Abstract Protocol Flow</p>
<p id="rfc.section.1.2.p.1">The abstract OAuth 2.1 flow illustrated in <a href="#fig-protocol-flow" class="xref">Figure 1</a> describes the interaction between the four roles and includes the following steps:</p>
<p></p>

<ol>
<li>The client requests authorization from the resource owner.  The authorization request can be made directly to the resource owner (as shown), or preferably indirectly via the authorization server as an intermediary.</li>
<li>The client receives an authorization grant, which is a credential representing the resource owner's authorization, expressed using one of two grant types defined in this specification or using an extension grant type.  The authorization grant type depends on the method used by the client to request authorization and the types supported by the authorization server.</li>
<li>The client requests an access token by authenticating with the authorization server and presenting the authorization grant.</li>
<li>The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token.</li>
<li>The client requests the protected resource from the resource server and authenticates by presenting the access token.</li>
<li>The resource server validates the access token, and if valid, serves the request.</li>
</ol>
<p id="rfc.section.1.2.p.3">The preferred method for the client to obtain an authorization grant from the resource owner (depicted in steps (1) and (2)) is to use the authorization server as an intermediary, which is illustrated in <a href="#fig-authorization-code-flow" class="xref">Figure 3</a> in <a href="#authorization-code-grant" class="xref">Section 4.1</a>.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> <a href="#authorization-grant" id="authorization-grant">Authorization Grant</a>
</h1>
<p id="rfc.section.1.3.p.1">An authorization grant is a credential representing the resource owner's authorization (to access its protected resources) used by the client to obtain an access token.  This specification defines two grant types &#8211; authorization code and client credentials &#8211; as well as an extensibility mechanism for defining additional types.</p>
<h1 id="rfc.section.1.3.1">
<a href="#rfc.section.1.3.1">1.3.1.</a> <a href="#authorization-code" id="authorization-code">Authorization Code</a>
</h1>
<p id="rfc.section.1.3.1.p.1">The authorization code is obtained by using an authorization server as an intermediary between the client and resource owner.  Instead of requesting authorization directly from the resource owner, the client directs the resource owner to an authorization server (via its user-agent as defined in <a href="#RFC2616" class="xref">[RFC2616]</a>), which in turn directs the resource owner back to the client with the authorization code.</p>
<p id="rfc.section.1.3.1.p.2">Before directing the resource owner back to the client with the authorization code, the authorization server authenticates the resource owner and obtains authorization.  Because the resource owner only authenticates with the authorization server, the resource owner's credentials are never shared with the client.</p>
<p id="rfc.section.1.3.1.p.3">The authorization code provides a few important security benefits, such as the ability to authenticate the client, as well as the transmission of the access token directly to the client without passing it through the resource owner's user-agent and potentially exposing it to others, including the resource owner.</p>
<h1 id="rfc.section.1.3.2">
<a href="#rfc.section.1.3.2">1.3.2.</a> <a href="#client-credentials" id="client-credentials">Client Credentials</a>
</h1>
<p id="rfc.section.1.3.2.p.1">The client credentials (or other forms of client authentication) can be used as an authorization grant when the authorization scope is limited to the protected resources under the control of the client, or to protected resources previously arranged with the authorization server.  Client credentials are used as an authorization grant typically when the client is acting on its own behalf (the client is also the resource owner) or is requesting access to protected resources based on an authorization previously arranged with the authorization server.</p>
<h1 id="rfc.section.1.4">
<a href="#rfc.section.1.4">1.4.</a> <a href="#access-token" id="access-token">Access Token</a>
</h1>
<p id="rfc.section.1.4.p.1">Access tokens are credentials used to access protected resources.  An access token is a string representing an authorization issued to the client.  The string is usually opaque to the client.  Tokens represent specific scopes and durations of access, granted by the resource owner, and enforced by the resource server and authorization server.</p>
<p id="rfc.section.1.4.p.2">The token may denote an identifier used to retrieve the authorization information or may self-contain the authorization information in a verifiable manner (i.e., a token string consisting of some data and a signature).  Additional authentication credentials, which are beyond the scope of this specification, may be required in order for the client to use a token.</p>
<p id="rfc.section.1.4.p.3">The access token provides an abstraction layer, replacing different authorization constructs (e.g., username and password) with a single token understood by the resource server.  This abstraction enables issuing access tokens more restrictive than the authorization grant used to obtain them, as well as removing the resource server's need to understand a wide range of authentication methods.</p>
<p id="rfc.section.1.4.p.4">Access tokens can have different formats, structures, and methods of utilization (e.g., cryptographic properties) based on the resource server security requirements.  Access token attributes and the methods used to access protected resources may be extended beyond what is described in this specification.</p>
<h1 id="rfc.section.1.5">
<a href="#rfc.section.1.5">1.5.</a> <a href="#refresh-token" id="refresh-token">Refresh Token</a>
</h1>
<p id="rfc.section.1.5.p.1">Refresh tokens are credentials used to obtain access tokens.  Refresh tokens are issued to the client by the authorization server and are used to obtain a new access token when the current access token becomes invalid or expires, or to obtain additional access tokens with identical or narrower scope (access tokens may have a shorter lifetime and fewer permissions than authorized by the resource owner).  Issuing a refresh token is optional at the discretion of the authorization server.  If the authorization server issues a refresh token, it is included when issuing an access token (i.e., step (4) in <a href="#fig-refresh-token-flow" class="xref">Figure 2</a>).</p>
<p id="rfc.section.1.5.p.2">A refresh token is a string representing the authorization granted to the client by the resource owner.  The string is usually opaque to the client.  The token denotes an identifier used to retrieve the authorization information.  Unlike access tokens, refresh tokens are intended for use only with authorization servers and are never sent to resource servers.</p>
<div id="rfc.figure.2"></div>
<div id="fig-refresh-token-flow"></div>
<pre>
+--------+                                           +---------------+
|        |--(1)------- Authorization Grant ---------&gt;|               |
|        |                                           |               |
|        |&lt;-(2)----------- Access Token -------------|               |
|        |               &amp; Refresh Token             |               |
|        |                                           |               |
|        |                            +----------+   |               |
|        |--(3)---- Access Token ----&gt;|          |   |               |
|        |                            |          |   |               |
|        |&lt;-(4)- Protected Resource --| Resource |   | Authorization |
| Client |                            |  Server  |   |     Server    |
|        |--(5)---- Access Token ----&gt;|          |   |               |
|        |                            |          |   |               |
|        |&lt;-(6)- Invalid Token Error -|          |   |               |
|        |                            +----------+   |               |
|        |                                           |               |
|        |--(7)----------- Refresh Token -----------&gt;|               |
|        |                                           |               |
|        |&lt;-(8)----------- Access Token -------------|               |
+--------+           &amp; Optional Refresh Token        +---------------+
</pre>
<p class="figure">Figure 2: Refreshing an Expired Access Token</p>
<p id="rfc.section.1.5.p.3">The flow illustrated in <a href="#fig-refresh-token-flow" class="xref">Figure 2</a> includes the following steps:</p>
<p></p>

<ol>
<li>The client requests an access token by authenticating with the authorization server and presenting an authorization grant.</li>
<li>The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token and a refresh token.</li>
<li>The client makes a protected resource request to the resource server by presenting the access token.</li>
<li>The resource server validates the access token, and if valid, serves the request.</li>
<li>Steps (3) and (4) repeat until the access token expires.  If the client knows the access token expired, it skips to step (7); otherwise, it makes another protected resource request.</li>
<li>Since the access token is invalid, the resource server returns an invalid token error.</li>
<li>The client requests a new access token by authenticating with the authorization server and presenting the refresh token.  The client authentication requirements are based on the client type and on the authorization server policies.</li>
<li>The authorization server authenticates the client and validates the refresh token, and if valid, issues a new access token (and, optionally, a new refresh token).</li>
</ol>
<p id="rfc.section.1.5.p.5">Steps (3), (4), (5), and (6) are outside the scope of this specification, as described in <a href="#accessing-protected-resources" class="xref">Section 7</a>.</p>
<h1 id="rfc.section.1.6">
<a href="#rfc.section.1.6">1.6.</a> <a href="#tls-version" id="tls-version">TLS Version</a>
</h1>
<p id="rfc.section.1.6.p.1">Whenever Transport Layer Security (TLS) is used by this specification, the appropriate version (or versions) of TLS will vary over time, based on the widespread deployment and known security vulnerabilities.  At the time of this writing, At the time of this writing, TLS version 1.3 <a href="#RFC8446" class="xref">[RFC8446]</a> is the most recent version.</p>
<p id="rfc.section.1.6.p.2">Implementations MAY also support additional transport-layer security mechanisms that meet their security requirements.</p>
<h1 id="rfc.section.1.7">
<a href="#rfc.section.1.7">1.7.</a> <a href="#http-redirections" id="http-redirections">HTTP Redirections</a>
</h1>
<p id="rfc.section.1.7.p.1">This specification makes extensive use of HTTP redirections, in which the client or the authorization server directs the resource owner's user-agent to another destination.  While the examples in this specification show the use of the HTTP 302 status code, any other method available via the user-agent to accomplish this redirection is allowed and is considered to be an implementation detail.</p>
<h1 id="rfc.section.1.8">
<a href="#rfc.section.1.8">1.8.</a> <a href="#interoperability" id="interoperability">Interoperability</a>
</h1>
<p id="rfc.section.1.8.p.1">OAuth 2.1 provides a rich authorization framework with well-defined security properties.  However, as a rich and highly extensible framework with many optional components, on its own, this specification is likely to produce a wide range of non-interoperable implementations.</p>
<p id="rfc.section.1.8.p.2">In addition, this specification leaves a few required components partially or fully undefined (e.g., client registration, authorization server capabilities, endpoint discovery).  Without these components, clients must be manually and specifically configured against a specific authorization server and resource server in order to interoperate.</p>
<p id="rfc.section.1.8.p.3">This framework was designed with the clear expectation that future work will define prescriptive profiles and extensions necessary to achieve full web-scale interoperability.</p>
<h1 id="rfc.section.1.9">
<a href="#rfc.section.1.9">1.9.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a>
</h1>
<p id="rfc.section.1.9.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this specification are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<p id="rfc.section.1.9.p.2">This specification uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234" class="xref">[RFC5234]</a>.  Additionally, the rule URI-reference is included from "Uniform Resource Identifier (URI): Generic Syntax" <a href="#RFC3986" class="xref">[RFC3986]</a>.</p>
<p id="rfc.section.1.9.p.3">Certain security-related terms are to be understood in the sense defined in <a href="#RFC4949" class="xref">[RFC4949]</a>.  These terms include, but are not limited to, "attack", "authentication", "authorization", "certificate", "confidentiality", "credential", "encryption", "identity", "sign", "signature", "trust", "validate", and "verify".</p>
<p id="rfc.section.1.9.p.4">Unless otherwise noted, all the protocol parameter names and values are case sensitive.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#client-registration" id="client-registration">Client Registration</a>
</h1>
<p id="rfc.section.2.p.1">Before initiating the protocol, the client registers with the authorization server.  The means through which the client registers with the authorization server are beyond the scope of this specification but typically involve end-user interaction with an HTML registration form.</p>
<p id="rfc.section.2.p.2">Client registration does not require a direct interaction between the client and the authorization server.  When supported by the authorization server, registration can rely on other means for establishing trust and obtaining the required client properties (e.g., redirection URI, client type).  For example, registration can be accomplished using a self-issued or third-party-issued assertion, or by the authorization server performing client discovery using a trusted channel.</p>
<p id="rfc.section.2.p.3">When registering a client, the client developer SHALL:</p>
<p></p>

<ul>
<li>specify the client type as described in <a href="#client-types" class="xref">Section 2.1</a>,</li>
<li>provide its client redirection URIs as described in <a href="#redirection-endpoint" class="xref">Section 3.1.2</a>, and</li>
<li>include any other information required by the authorization server (e.g., application name, website, description, logo image, the acceptance of legal terms).</li>
</ul>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#client-types" id="client-types">Client Types</a>
</h1>
<p id="rfc.section.2.1.p.1">OAuth defines two client types, based on whether they can be issued credentials that they can use to authenticate at the authorization server:</p>
<p></p>

<dl>
<dt>"confidential":</dt>
<dd style="margin-left: 8">Clients capable of maintaining the confidentiality of their credentials (e.g., client implemented on a secure server with restricted access to the client credentials), or capable of secure client authentication using other means.</dd>
<dt>"public":</dt>
<dd style="margin-left: 8">Clients incapable of maintaining the confidentiality of their credentials (e.g., clients executing on the device used by the resource owner, such as an installed native application or a web browser-based application), and incapable of secure client authentication via any other means.</dd>
</dl>
<p id="rfc.section.2.1.p.3">The client type designation is based on the authorization server's definition of secure authentication and its acceptable exposure levels of client credentials.  The authorization server SHOULD NOT make assumptions about the client type.</p>
<p id="rfc.section.2.1.p.4">A client may be implemented as a distributed set of components, each with a different client type and security context (e.g., a distributed client with both a confidential server-based component and a public browser-based component).  If the authorization server does not provide support for such clients or does not provide guidance with regard to their registration, the client SHOULD register each component as a separate client.</p>
<p id="rfc.section.2.1.p.5">This specification has been designed around the following client profiles:</p>
<p></p>

<dl>
<dt>"web application":</dt>
<dd style="margin-left: 8">A web application is a confidential client running on a web server.  Resource owners access the client via an HTML user interface rendered in a user-agent on the device used by the resource owner.  The client credentials as well as any access token issued to the client are stored on the web server and are not exposed to or accessible by the resource owner.</dd>
<dt>"browser-based application":</dt>
<dd style="margin-left: 8">A browser-based application is a public client in which the client code is downloaded from a web server and executes within a user-agent (e.g., web browser) on the device used by the resource owner.  Protocol data and credentials are easily accessible (and often visible) to the resource owner.  Since such applications reside within the user-agent, they can make seamless use of the user-agent capabilities when requesting authorization.</dd>
<dt>"native application":</dt>
<dd style="margin-left: 8">A native application is a public client installed and executed on the device used by the resource owner.  Protocol data and credentials are accessible to the resource owner.  It is assumed that any client authentication credentials included in the application can be extracted.  On the other hand, dynamically issued credentials such as access tokens or refresh tokens can receive an acceptable level of protection.  At a minimum, these credentials are protected from hostile servers with which the application may interact.  On some platforms, these credentials might be protected from other applications residing on the same device.</dd>
</dl>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#client-identifier" id="client-identifier">Client Identifier</a>
</h1>
<p id="rfc.section.2.2.p.1">The authorization server issues the registered client a client identifier &#8211; a unique string representing the registration information provided by the client.  The client identifier is not a secret; it is exposed to the resource owner and MUST NOT be used alone for client authentication.  The client identifier is unique to the authorization server.</p>
<p id="rfc.section.2.2.p.2">The client identifier string size is left undefined by this specification.  The client should avoid making assumptions about the identifier size.  The authorization server SHOULD document the size of any identifier it issues.</p>
<p id="rfc.section.2.2.p.3">Authorization servers SHOULD NOT allow clients to influence their "client_id" or "sub" value or any other claim if that can cause confusion with a genuine resource owner.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#client-authentication" id="client-authentication">Client Authentication</a>
</h1>
<p id="rfc.section.2.3.p.1">If the client type is confidential, the client and authorization server establish a client authentication method suitable for the security requirements of the authorization server.  The authorization server MAY accept any form of client authentication meeting its security requirements.</p>
<p id="rfc.section.2.3.p.2">Confidential clients are typically issued (or establish) a set of client credentials used for authenticating with the authorization server (e.g., password, public/private key pair).</p>
<p id="rfc.section.2.3.p.3">Authorization servers SHOULD use client authentication if possible.</p>
<p id="rfc.section.2.3.p.4">It is RECOMMENDED to use asymmetric (public-key based) methods for client authentication such as mTLS <a href="#RFC8705" class="xref">[RFC8705]</a> or "private_key_jwt" <a href="#OpenID" class="xref">[OpenID]</a>.  When asymmetric methods for client authentication are used, authorization servers do not need to store sensitive symmetric keys, making these methods more robust against a number of attacks.</p>
<p id="rfc.section.2.3.p.5">The authorization server MAY establish a client authentication method with public clients.  However, the authorization server MUST NOT rely on public client authentication for the purpose of identifying the client.</p>
<p id="rfc.section.2.3.p.6">The client MUST NOT use more than one authentication method in each request.</p>
<h1 id="rfc.section.2.3.1">
<a href="#rfc.section.2.3.1">2.3.1.</a> <a href="#client-password" id="client-password">Client Password</a>
</h1>
<p id="rfc.section.2.3.1.p.1">Clients in possession of a client password MAY use the HTTP Basic authentication scheme as defined in <a href="#RFC2617" class="xref">[RFC2617]</a> to authenticate with the authorization server.  The client identifier is encoded using the "application/x-www-form-urlencoded" encoding algorithm per Appendix B, and the encoded value is used as the username; the client password is encoded using the same algorithm and used as the password.  The authorization server MUST support the HTTP Basic authentication scheme for authenticating clients that were issued a client password.</p>
<p id="rfc.section.2.3.1.p.2">For example (with extra line breaks for display purposes only):</p>
<pre>
Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
</pre>
<p id="rfc.section.2.3.1.p.3">Alternatively, the authorization server MAY support including the client credentials in the request-body using the following parameters:</p>
<p></p>

<dl>
<dt>"client_id":</dt>
<dd style="margin-left: 8">REQUIRED.  The client identifier issued to the client during the registration process described by <a href="#client-identifier" class="xref">Section 2.2</a>.</dd>
<dt>"client_secret":</dt>
<dd style="margin-left: 8">REQUIRED.  The client secret.  The client MAY omit the parameter if the client secret is an empty string.</dd>
</dl>
<p id="rfc.section.2.3.1.p.5">Including the client credentials in the request-body using the two parameters is NOT RECOMMENDED and SHOULD be limited to clients unable to directly utilize the HTTP Basic authentication scheme (or other password-based HTTP authentication schemes).  The parameters can only be transmitted in the request-body and MUST NOT be included in the request URI.</p>
<p id="rfc.section.2.3.1.p.6">For example, a request to refresh an access token (<a href="#refreshing-an-access-token" class="xref">Section 6</a>) using the body parameters (with extra line breaks for display purposes only):</p>
<pre>
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&amp;client_id=s6BhdRkqt3&amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
</pre>
<p id="rfc.section.2.3.1.p.7">The authorization server MUST require the use of TLS as described in <a href="#tls-version" class="xref">Section 1.6</a> when sending requests using password authentication.</p>
<p id="rfc.section.2.3.1.p.8">Since this client authentication method involves a password, the authorization server MUST protect any endpoint utilizing it against brute force attacks.</p>
<h1 id="rfc.section.2.3.2">
<a href="#rfc.section.2.3.2">2.3.2.</a> <a href="#other-authorization-methods" id="other-authorization-methods">Other Authorization Methods</a>
</h1>
<p id="rfc.section.2.3.2.p.1">The authorization server MAY support any suitable HTTP authentication scheme matching its security requirements.  When using other authentication methods, the authorization server MUST define a mapping between the client identifier (registration record) and authentication scheme.</p>
<h1 id="rfc.section.2.4">
<a href="#rfc.section.2.4">2.4.</a> <a href="#unregistered-clients" id="unregistered-clients">Unregistered Clients</a>
</h1>
<p id="rfc.section.2.4.p.1">This specification does not exclude the use of unregistered clients.  However, the use of such clients is beyond the scope of this specification and requires additional security analysis and review of its interoperability impact.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#protocol-endpoints" id="protocol-endpoints">Protocol Endpoints</a>
</h1>
<p id="rfc.section.3.p.1">The authorization process utilizes two authorization server endpoints (HTTP resources):</p>
<p></p>

<ul>
<li>Authorization endpoint - used by the client to obtain authorization from the resource owner via user-agent redirection.</li>
<li>Token endpoint - used by the client to exchange an authorization grant for an access token, typically with client authentication.</li>
</ul>
<p id="rfc.section.3.p.3">As well as one client endpoint:</p>
<p></p>

<ul><li>Redirection endpoint - used by the authorization server to return responses containing authorization credentials to the client via the resource owner user-agent.</li></ul>
<p id="rfc.section.3.p.5">Not every authorization grant type utilizes both endpoints.  Extension grant types MAY define additional endpoints as needed.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#authorization-endpoint" id="authorization-endpoint">Authorization Endpoint</a>
</h1>
<p id="rfc.section.3.1.p.1">The authorization endpoint is used to interact with the resource owner and obtain an authorization grant.  The authorization server MUST first verify the identity of the resource owner.  The way in which the authorization server authenticates the resource owner (e.g., username and password login, session cookies) is beyond the scope of this specification.</p>
<p id="rfc.section.3.1.p.2">The means through which the client obtains the location of the authorization endpoint are beyond the scope of this specification, but the location is typically provided in the service documentation.</p>
<p id="rfc.section.3.1.p.3">The endpoint URI MAY include an "application/x-www-form-urlencoded" formatted (per Appendix B) query component (<a href="#RFC3986" class="xref">[RFC3986]</a> Section 3.4), which MUST be retained when adding additional query parameters.  The endpoint URI MUST NOT include a fragment component.</p>
<p id="rfc.section.3.1.p.4">Since requests to the authorization endpoint result in user authentication and the transmission of clear-text credentials (in the HTTP response), the authorization server MUST require the use of TLS as described in <a href="#tls-version" class="xref">Section 1.6</a> when sending requests to the authorization endpoint.</p>
<p id="rfc.section.3.1.p.5">The authorization server MUST support the use of the HTTP "GET" method <a href="#RFC2616" class="xref">[RFC2616]</a> for the authorization endpoint and MAY support the use of the "POST" method as well.</p>
<p id="rfc.section.3.1.p.6">Parameters sent without a value MUST be treated as if they were omitted from the request.  The authorization server MUST ignore unrecognized request parameters.  Request and response parameters MUST NOT be included more than once.</p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#response-type" id="response-type">Response Type</a>
</h1>
<p id="rfc.section.3.1.1.p.1">The authorization endpoint is used by the authorization code flow.  The client informs the authorization server of the desired grant type using the following parameter:</p>
<p></p>

<dl>
<dt>"response_type":</dt>
<dd style="margin-left: 8">REQUIRED.  The value MUST be "code" for requesting an authorization code as described by <a href="#authorization-request" class="xref">Section 4.1.1</a>, or a registered extension value as described by <a href="#new-response-types" class="xref">Section 8.4</a>.</dd>
</dl>
<p id="rfc.section.3.1.1.p.3">Extension response types MAY contain a space-delimited (%x20) list of values, where the order of values does not matter (e.g., response type "a b" is the same as "b a").  The meaning of such composite response types is defined by their respective specifications.</p>
<p id="rfc.section.3.1.1.p.4">If an authorization request is missing the "response_type" parameter, or if the response type is not understood, the authorization server MUST return an error response as described in <a href="#authorization-code-error-response" class="xref">Section 4.1.2.1</a>.</p>
<h1 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#redirection-endpoint" id="redirection-endpoint">Redirection Endpoint</a>
</h1>
<p id="rfc.section.3.1.2.p.1">After completing its interaction with the resource owner, the authorization server directs the resource owner's user-agent back to the client.  The authorization server redirects the user-agent to the client's redirection endpoint previously established with the authorization server during the client registration process.</p>
<p id="rfc.section.3.1.2.p.2">The authorization server MUST compare the two URIs using simple string comparison as defined in <a href="#RFC3986" class="xref">[RFC3986]</a>, Section 6.2.1.</p>
<p id="rfc.section.3.1.2.p.3">The redirection endpoint URI MUST be an absolute URI as defined by <a href="#RFC3986" class="xref">[RFC3986]</a> Section 4.3.  The endpoint URI MAY include an "application/x-www-form-urlencoded" formatted (per Appendix B) query component (<a href="#RFC3986" class="xref">[RFC3986]</a> Section 3.4), which MUST be retained when adding additional query parameters.  The endpoint URI MUST NOT include a fragment component.</p>
<h1 id="rfc.section.3.1.2.1">
<a href="#rfc.section.3.1.2.1">3.1.2.1.</a> <a href="#endpoint-request-confidentiality" id="endpoint-request-confidentiality">Endpoint Request Confidentiality</a>
</h1>
<p id="rfc.section.3.1.2.1.p.1">The redirection endpoint SHOULD require the use of TLS as described in <a href="#tls-version" class="xref">Section 1.6</a> when the requested response type is "code", or when the redirection request will result in the transmission of sensitive credentials over an open network.  This specification does not mandate the use of TLS because at the time of this writing, requiring clients to deploy TLS is a significant hurdle for many client developers.  If TLS is not available, the authorization server SHOULD warn the resource owner about the insecure endpoint prior to redirection (e.g., display a message during the authorization request).</p>
<p id="rfc.section.3.1.2.1.p.2">Lack of transport-layer security can have a severe impact on the security of the client and the protected resources it is authorized to access.  The use of transport-layer security is particularly critical when the authorization process is used as a form of delegated end-user authentication by the client (e.g., third-party sign-in service).</p>
<h1 id="rfc.section.3.1.2.2">
<a href="#rfc.section.3.1.2.2">3.1.2.2.</a> <a href="#registration-requirements" id="registration-requirements">Registration Requirements</a>
</h1>
<p id="rfc.section.3.1.2.2.p.1">The authorization server MUST require all clients to register their redirection endpoint prior to utilizing the authorization endpoint.</p>
<p id="rfc.section.3.1.2.2.p.2">The authorization server SHOULD require the client to provide the complete redirection URI (the client MAY use the "state" request parameter to achieve per-request customization).</p>
<p id="rfc.section.3.1.2.2.p.3">The authorization server MAY allow the client to register multiple redirection endpoints.</p>
<p id="rfc.section.3.1.2.2.p.4">Lack of a redirection URI registration requirement can enable an attacker to use the authorization endpoint as an open redirector as described in <a href="#open-redirectors" class="xref">Section 10.17</a>.</p>
<h1 id="rfc.section.3.1.2.3">
<a href="#rfc.section.3.1.2.3">3.1.2.3.</a> <a href="#dynamic-configuration" id="dynamic-configuration">Dynamic Configuration</a>
</h1>
<p id="rfc.section.3.1.2.3.p.1">If multiple redirection URIs have been registered the client MUST include a redirection URI with the authorization request using the "redirect_uri" request parameter.</p>
<p id="rfc.section.3.1.2.3.p.2">When a redirection URI is included in an authorization request, the authorization server MUST compare and match the value received against at least one of the registered redirection URIs (or URI components) as defined in <a href="#RFC3986" class="xref">[RFC3986]</a> Section 6, if any redirection URIs were registered.  If the client registration included the full redirection URI, the authorization server MUST compare the two URIs using simple string comparison as defined in <a href="#RFC3986" class="xref">[RFC3986]</a> Section 6.2.1.</p>
<h1 id="rfc.section.3.1.2.4">
<a href="#rfc.section.3.1.2.4">3.1.2.4.</a> <a href="#invalid-endpoint" id="invalid-endpoint">Invalid Endpoint</a>
</h1>
<p id="rfc.section.3.1.2.4.p.1">If an authorization request fails validation due to a missing, invalid, or mismatching redirection URI, the authorization server SHOULD inform the resource owner of the error and MUST NOT automatically redirect the user-agent to the invalid redirection URI.</p>
<h1 id="rfc.section.3.1.2.5">
<a href="#rfc.section.3.1.2.5">3.1.2.5.</a> <a href="#endpoint-content" id="endpoint-content">Endpoint Content</a>
</h1>
<p id="rfc.section.3.1.2.5.p.1">The redirection request to the client's endpoint typically results in an HTML document response, processed by the user-agent.  If the HTML response is served directly as the result of the redirection request, any script included in the HTML document will execute with full access to the redirection URI and the credentials it contains.</p>
<p id="rfc.section.3.1.2.5.p.2">The client SHOULD NOT include any third-party scripts (e.g., third- party analytics, social plug-ins, ad networks) in the redirection endpoint response.  Instead, it SHOULD extract the credentials from the URI and redirect the user-agent again to another endpoint without exposing the credentials (in the URI or elsewhere).  If third-party scripts are included, the client MUST ensure that its own scripts (used to extract and remove the credentials from the URI) will execute first.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#token-endpoint" id="token-endpoint">Token Endpoint</a>
</h1>
<p id="rfc.section.3.2.p.1">The token endpoint is used by the client to obtain an access token by presenting its authorization grant or refresh token.</p>
<p id="rfc.section.3.2.p.2">The means through which the client obtains the location of the token endpoint are beyond the scope of this specification, but the location is typically provided in the service documentation.</p>
<p id="rfc.section.3.2.p.3">The endpoint URI MAY include an "application/x-www-form-urlencoded" formatted (per Appendix B) query component (<a href="#RFC3986" class="xref">[RFC3986]</a> Section 3.4), which MUST be retained when adding additional query parameters.  The endpoint URI MUST NOT include a fragment component.</p>
<p id="rfc.section.3.2.p.4">Since requests to the token endpoint result in the transmission of clear-text credentials (in the HTTP request and response), the authorization server MUST require the use of TLS as described in <a href="#tls-version" class="xref">Section 1.6</a> when sending requests to the token endpoint.</p>
<p id="rfc.section.3.2.p.5">The client MUST use the HTTP "POST" method when making access token requests.</p>
<p id="rfc.section.3.2.p.6">Parameters sent without a value MUST be treated as if they were omitted from the request.  The authorization server MUST ignore unrecognized request parameters.  Request and response parameters MUST NOT be included more than once.</p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#token-endpoint-client-authentication" id="token-endpoint-client-authentication">Client Authentication</a>
</h1>
<p id="rfc.section.3.2.1.p.1">Confidential clients or other clients issued client credentials MUST authenticate with the authorization server as described in <a href="#client-authentication" class="xref">Section 2.3</a> when making requests to the token endpoint.  Client authentication is used for:</p>
<p></p>

<ul>
<li>Enforcing the binding of refresh tokens and authorization codes to the client they were issued to.  Client authentication is critical when an authorization code is transmitted to the redirection endpoint over an insecure channel or when the redirection URI has not been registered in full.</li>
<li>Recovering from a compromised client by disabling the client or changing its credentials, thus preventing an attacker from abusing stolen refresh tokens.  Changing a single set of client credentials is significantly faster than revoking an entire set of refresh tokens.</li>
<li>Implementing authentication management best practices, which require periodic credential rotation.  Rotation of an entire set of refresh tokens can be challenging, while rotation of a single set of client credentials is significantly easier.</li>
</ul>
<p id="rfc.section.3.2.1.p.3">A client MAY use the "client_id" request parameter to identify itself when sending requests to the token endpoint.  In the "authorization_code" "grant_type" request to the token endpoint, an unauthenticated client MUST send its "client_id" to prevent itself from inadvertently accepting a code intended for a client with a different "client_id".  This protects the client from substitution of the authentication code.  (It provides no additional security for the protected resource.)</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#access-token-scope" id="access-token-scope">Access Token Scope</a>
</h1>
<p id="rfc.section.3.3.p.1">The authorization and token endpoints allow the client to specify the scope of the access request using the "scope" request parameter.  In turn, the authorization server uses the "scope" response parameter to inform the client of the scope of the access token issued.</p>
<p id="rfc.section.3.3.p.2">The value of the scope parameter is expressed as a list of space- delimited, case-sensitive strings.  The strings are defined by the authorization server.  If the value contains multiple space-delimited strings, their order does not matter, and each string adds an additional access range to the requested scope.</p>
<pre>
    scope       = scope-token *( SP scope-token )
    scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
</pre>
<p id="rfc.section.3.3.p.3">The authorization server MAY fully or partially ignore the scope requested by the client, based on the authorization server policy or the resource owner's instructions.  If the issued access token scope is different from the one requested by the client, the authorization server MUST include the "scope" response parameter to inform the client of the actual scope granted.</p>
<p id="rfc.section.3.3.p.4">If the client omits the scope parameter when requesting authorization, the authorization server MUST either process the request using a pre-defined default value or fail the request indicating an invalid scope.  The authorization server SHOULD document its scope requirements and default value (if defined).</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#obtaining-authorization" id="obtaining-authorization">Obtaining Authorization</a>
</h1>
<p id="rfc.section.4.p.1">To request an access token, the client obtains authorization from the resource owner.  The authorization is expressed in the form of an authorization grant, which the client uses to request the access token.  OAuth defines two grant types: authorization code and client credentials.  It also provides an extension mechanism for defining additional grant types.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#authorization-code-grant" id="authorization-code-grant">Authorization Code Grant</a>
</h1>
<p id="rfc.section.4.1.p.1">The authorization code grant type is used to obtain both access tokens and refresh tokens.</p>
<p id="rfc.section.4.1.p.2">Since this is a redirection-based flow, the client must be capable of interacting with the resource owner's user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the authorization server.</p>
<div id="rfc.figure.3"></div>
<div id="fig-authorization-code-flow"></div>
<pre>
+----------+
| Resource |
|   Owner  |
|          |
+----------+
     ^
     |
    (2)
+----|-----+          Client Identifier      +---------------+
|         -+----(1)-- &amp; Redirection URI ----&gt;|               |
|  User-   |                                 | Authorization |
|  Agent  -+----(2)-- User authenticates ---&gt;|     Server    |
|          |                                 |               |
|         -+----(3)-- Authorization Code ---&lt;|               |
+-|----|---+                                 +---------------+
  |    |                                         ^      v
 (1)  (3)                                        |      |
  |    |                                         |      |
  ^    v                                         |      |
+---------+                                      |      |
|         |&gt;---(4)-- Authorization Code ---------'      |
|  Client |          &amp; Redirection URI                  |
|         |                                             |
|         |&lt;---(5)----- Access Token -------------------'
+---------+       (w/ Optional Refresh Token)

Note: The lines illustrating steps (1), (2), and (3) are broken into
two parts as they pass through the user-agent.
</pre>
<p class="figure">Figure 3: Authorization Code Flow</p>
<p id="rfc.section.4.1.p.3">The flow illustrated in <a href="#fig-authorization-code-flow" class="xref">Figure 3</a> includes the following steps:</p>
<p id="rfc.section.4.1.p.4">(1)  The client initiates the flow by directing the resource owner's user-agent to the authorization endpoint.  The client includes its client identifier, requested scope, local state, PKCE code challenge, and a redirection URI to which the authorization server will send the user-agent back once access is granted (or denied).</p>
<p id="rfc.section.4.1.p.5">(2)  The authorization server authenticates the resource owner (via the user-agent) and establishes whether the resource owner grants or denies the client's access request.</p>
<p id="rfc.section.4.1.p.6">(3)  Assuming the resource owner grants access, the authorization server redirects the user-agent back to the client using the redirection URI provided earlier (in the request or during client registration).  The redirection URI includes an authorization code and any local state provided by the client earlier.</p>
<p id="rfc.section.4.1.p.7">(4)  The client requests an access token from the authorization server's token endpoint by including the authorization code received in the previous step, and including its code verifier.  When making the request, the client authenticates with the authorization server if it can.  The client includes the redirection URI used to obtain the authorization code for verification.</p>
<p id="rfc.section.4.1.p.8">(5)  The authorization server authenticates the client when possible, validates the authorization code, validates the code verifier, and ensures that the redirection URI received matches the URI used to redirect the client in step (C).  If valid, the authorization server responds back with an access token and, optionally, a refresh token.</p>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#authorization-request" id="authorization-request">Authorization Request</a>
</h1>
<p id="rfc.section.4.1.1.p.1">To begin the authorization request, the client builds the authorization request URI by adding parameters to the authorization server's authorization endpoint URI.</p>
<p id="rfc.section.4.1.1.p.2">Without a client secret, public clients would be susceptible to an authorization code interception attack, where an attacker is able to intercept the authorization response through various means and use the authorization code to obtain an access token.  To protect against this attack, as well as to protect against CSRF attacks, the client first generates a unique secret per authorization request, which it can later use along with the authorization code to prove that the application using the authorization code is the same application that requested it. This practice is known as "Proof-Key for Code Exchange", or PKCE, after the OAuth 2.0 extension (<a href="#RFC7636" class="xref">[RFC7636]</a>) where it was originally developed.</p>
<h1 id="rfc.section.4.1.1.1">
<a href="#rfc.section.4.1.1.1">4.1.1.1.</a> <a href="#client-creates-a-pkce-code-verifier" id="client-creates-a-pkce-code-verifier">Client Creates a PKCE Code Verifier</a>
</h1>
<p id="rfc.section.4.1.1.1.p.1">The client first creates a PKCE code verifier, <samp>code_verifier</samp>, for each Authorization Request, in the following manner:</p>
<pre>
code_verifier = high-entropy cryptographic random STRING using the
unreserved characters `[A-Z] / [a-z] / [0-9] / "-" / "." / "_" / "~"`
from Section 2.3 of {{RFC3986}}, with a minimum length of 43 characters
and a maximum length of 128 characters.
</pre>
<p id="rfc.section.4.1.1.1.p.2">ABNF for <samp>code_verifier</samp> is as follows.</p>
<pre>
code-verifier = 43*128unreserved
unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
ALPHA = %x41-5A / %x61-7A
DIGIT = %x30-39
</pre>
<p id="rfc.section.4.1.1.1.p.3">NOTE: The code verifier SHOULD have enough entropy to make it impractical to guess the value.  It is RECOMMENDED that the output of a suitable random number generator be used to create a 32-octet sequence.  The octet sequence is then base64url-encoded to produce a 43-octet URL-safe string to use as the code verifier.</p>
<h1 id="rfc.section.4.1.1.2">
<a href="#rfc.section.4.1.1.2">4.1.1.2.</a> <a href="#client-creates-the-pkce-code-challenge" id="client-creates-the-pkce-code-challenge">Client Creates the PKCE Code Challenge</a>
</h1>
<p id="rfc.section.4.1.1.2.p.1">The client then creates a PKCE code challenge derived from the code verifier by using one of the following transformations on the code verifier:</p>
<pre>
plain
  code_challenge = code_verifier

S256
  code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))
</pre>
<p id="rfc.section.4.1.1.2.p.2">If the client is capable of using <samp>S256</samp>, it MUST use <samp>S256</samp>, as <samp>S256</samp> is Mandatory To Implement (MTI) on the server.  Clients are permitted to use <samp>plain</samp> only if they cannot support <samp>S256</samp> for some technical reason and know via out-of-band configuration that the server supports <samp>plain</samp>.</p>
<p id="rfc.section.4.1.1.2.p.3">The plain transformation is for compatibility with existing deployments and for constrained environments that can't use the S256 transformation.</p>
<p id="rfc.section.4.1.1.2.p.4">ABNF for "code_challenge" is as follows.</p>
<pre>
code-challenge = 43*128unreserved
unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
ALPHA = %x41-5A / %x61-7A
DIGIT = %x30-39
</pre>
<h1 id="rfc.section.4.1.1.3">
<a href="#rfc.section.4.1.1.3">4.1.1.3.</a> <a href="#client-initiates-the-authorization-request" id="client-initiates-the-authorization-request">Client Initiates the Authorization Request</a>
</h1>
<p id="rfc.section.4.1.1.3.p.1">The client constructs the request URI by adding the following parameters to the query component of the authorization endpoint URI using the "application/x-www-form-urlencoded" format, per Appendix B:</p>
<p></p>

<dl>
<dt>"response_type":</dt>
<dd style="margin-left: 8">REQUIRED.  Value MUST be set to <samp>code</samp>.</dd>
<dt>"client_id":</dt>
<dd style="margin-left: 8">REQUIRED.  The client identifier as described in <a href="#client-identifier" class="xref">Section 2.2</a>.</dd>
<dt>"code_challenge":</dt>
<dd style="margin-left: 8">REQUIRED.  Code challenge.</dd>
<dt>"code_challenge_method":</dt>
<dd style="margin-left: 8">OPTIONAL, defaults to <samp>plain</samp> if not present in the request.  Code nverifier transformation method is <samp>S256</samp> or <samp>plain</samp>.</dd>
<dt>"redirect_uri":</dt>
<dd style="margin-left: 8">OPTIONAL.  As described in <a href="#redirection-endpoint" class="xref">Section 3.1.2</a>.</dd>
<dt>"scope":</dt>
<dd style="margin-left: 8">OPTIONAL.  The scope of the access request as described by <a href="#access-token-scope" class="xref">Section 3.3</a>.</dd>
<dt>"state":</dt>
<dd style="margin-left: 8">OPTIONAL.  An opaque value used by the client to maintain state between the request and callback.  The authorization server includes this value when redirecting the user-agent back to the client.</dd>
</dl>
<p id="rfc.section.4.1.1.3.p.3">The client directs the resource owner to the constructed URI using an HTTP redirection response, or by other means available to it via the user-agent.</p>
<p id="rfc.section.4.1.1.3.p.4">For example, the client directs the user-agent to make the following HTTP request using TLS (with extra line breaks for display purposes only):</p>
<pre>
GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz
    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
    &amp;code_challenge=6fdkQaPm51l13DSukcAH3Mdx7_ntecHYd1vi3n0hMZY
    &amp;code_challenge_method=S256 HTTP/1.1
Host: server.example.com
</pre>
<p id="rfc.section.4.1.1.3.p.5">The authorization server validates the request to ensure that all required parameters are present and valid.  If the request is valid, the authorization server authenticates the resource owner and obtains an authorization decision (by asking the resource owner or by establishing approval via other means).</p>
<p id="rfc.section.4.1.1.3.p.6">When a decision is established, the authorization server directs the user-agent to the provided client redirection URI using an HTTP redirection response, or by other means available to it via the user-agent.</p>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#authorization-response" id="authorization-response">Authorization Response</a>
</h1>
<p id="rfc.section.4.1.2.p.1">If the resource owner grants the access request, the authorization server issues an authorization code and delivers it to the client by adding the following parameters to the query component of the redirection URI using the "application/x-www-form-urlencoded" format, per Appendix B:</p>
<p></p>

<dl>
<dt>"code":</dt>
<dd style="margin-left: 8">REQUIRED.  The authorization code generated by the authorization server.  The authorization code MUST expire shortly after it is issued to mitigate the risk of leaks.  A maximum authorization code lifetime of 10 minutes is RECOMMENDED.  The client MUST NOT use the authorization code more than once.  If an authorization code is used more than once, the authorization server MUST deny the request and SHOULD revoke (when possible) all tokens previously issued based on that authorization code.  The authorization code is bound to the client identifier and redirection URI.</dd>
<dt>"state":</dt>
<dd style="margin-left: 8">REQUIRED if the "state" parameter was present in the client authorization request.  The exact value received from the client.</dd>
</dl>
<p id="rfc.section.4.1.2.p.3">For example, the authorization server redirects the user-agent by sending the following HTTP response:</p>
<pre>
HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
          &amp;state=xyz
</pre>
<p id="rfc.section.4.1.2.p.4">The client MUST ignore unrecognized response parameters.  The authorization code string size is left undefined by this specification.  The client should avoid making assumptions about code value sizes.  The authorization server SHOULD document the size of any value it issues.</p>
<p id="rfc.section.4.1.2.p.5">When the server issues the authorization code in the authorization response, it MUST associate the "code_challenge" and "code_challenge_method" values with the authorization code so it can be verified later.</p>
<p id="rfc.section.4.1.2.p.6">Typically, the "code_challenge" and "code_challenge_method" values are stored in encrypted form in the "code" itself but could alternatively be stored on the server associated with the code.  The server MUST NOT include the "code_challenge" value in client requests in a form that other entities can extract.</p>
<p id="rfc.section.4.1.2.p.7">The exact method that the server uses to associate the "code_challenge" with the issued "code" is out of scope for this specification.</p>
<h1 id="rfc.section.4.1.2.1">
<a href="#rfc.section.4.1.2.1">4.1.2.1.</a> <a href="#authorization-code-error-response" id="authorization-code-error-response">Error Response</a>
</h1>
<p id="rfc.section.4.1.2.1.p.1">If the request fails due to a missing, invalid, or mismatching redirection URI, or if the client identifier is missing or invalid, the authorization server SHOULD inform the resource owner of the error and MUST NOT automatically redirect the user-agent to the invalid redirection URI.</p>
<p id="rfc.section.4.1.2.1.p.2">If the client does not send the "code_challenge" in the request, the authorization endpoint MUST return the authorization error response with the "error" value set to "invalid_request".  The "error_description" or the response of "error_uri" SHOULD explain the nature of error, e.g., code challenge required.</p>
<p id="rfc.section.4.1.2.1.p.3">If the server supporting PKCE does not support the requested transformation, the authorization endpoint MUST return the authorization error response with "error" value set to "invalid_request".  The "error_description" or the response of "error_uri" SHOULD explain the nature of error, e.g., transform algorithm not supported.</p>
<p id="rfc.section.4.1.2.1.p.4">If the resource owner denies the access request or if the request fails for reasons other than a missing or invalid redirection URI, the authorization server informs the client by adding the following parameters to the query component of the redirection URI using the "application/x-www-form-urlencoded" format, per Appendix B:</p>
<p></p>

<dl>
<dt>"error":</dt>
<dd style="margin-left: 8">REQUIRED.  A single ASCII <a href="#USASCII" class="xref">[USASCII]</a> error code from the following: <dl>
<dt>"invalid_request":</dt>
<dd style="margin-left: 8">The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed.</dd>
<dt>"unauthorized_client":</dt>
<dd style="margin-left: 8">The client is not authorized to request an authorization code using this method.</dd>
<dt>"access_denied":</dt>
<dd style="margin-left: 8">The resource owner or authorization server denied the request.</dd>
<dt>"unsupported_response_type":</dt>
<dd style="margin-left: 8">The authorization server does not support obtaining an authorization code using this method.</dd>
<dt>"invalid_scope":</dt>
<dd style="margin-left: 8">The requested scope is invalid, unknown, or malformed.</dd>
<dt>"server_error":</dt>
<dd style="margin-left: 8">The authorization server encountered an unexpected condition that prevented it from fulfilling the request.  (This error code is needed because a 500 Internal Server Error HTTP status code cannot be returned to the client via an HTTP redirect.)</dd>
<dt>"temporarily_unavailable":</dt>
<dd style="margin-left: 8">The authorization server is currently unable to handle the request due to a temporary overloading or maintenance of the server.  (This error code is needed because a 503 Service Unavailable HTTP status code cannot be returned to the client via an HTTP redirect.)</dd>
</dl>
<p> Values for the "error" parameter MUST NOT include characters outside the set %x20-21 / %x23-5B / %x5D-7E.</p>
</dd>
<dt>"error_description":</dt>
<dd style="margin-left: 8">OPTIONAL.  Human-readable ASCII <a href="#USASCII" class="xref">[USASCII]</a> text providing additional information, used to assist the client developer in understanding the error that occurred.  Values for the "error_description" parameter MUST NOT include characters outside the set %x20-21 / %x23-5B / %x5D-7E.</dd>
<dt>"error_uri":</dt>
<dd style="margin-left: 8">OPTIONAL.  A URI identifying a human-readable web page with information about the error, used to provide the client developer with additional information about the error.  Values for the "error_uri" parameter MUST conform to the URI-reference syntax and thus MUST NOT include characters outside the set %x21 / %x23-5B / %x5D-7E.</dd>
<dt>"state":</dt>
<dd style="margin-left: 8">REQUIRED if a "state" parameter was present in the client authorization request.  The exact value received from the client.</dd>
</dl>
<p id="rfc.section.4.1.2.1.p.6">For example, the authorization server redirects the user-agent by sending the following HTTP response:</p>
<pre>
HTTP/1.1 302 Found
Location: https://client.example.com/cb?error=access_denied&amp;state=xyz
</pre>
<h1 id="rfc.section.4.1.3">
<a href="#rfc.section.4.1.3">4.1.3.</a> <a href="#access-token-request" id="access-token-request">Access Token Request</a>
</h1>
<p id="rfc.section.4.1.3.p.1">The client makes a request to the token endpoint by sending the following parameters using the "application/x-www-form-urlencoded" format per Appendix B with a character encoding of UTF-8 in the HTTP request entity-body:</p>
<p></p>

<dl>
<dt>"grant_type":</dt>
<dd style="margin-left: 8">REQUIRED.  Value MUST be set to "authorization_code".</dd>
<dt>"code":</dt>
<dd style="margin-left: 8">REQUIRED.  The authorization code received from the authorization server.</dd>
<dt>"redirect_uri":</dt>
<dd style="margin-left: 8">REQUIRED, if the "redirect_uri" parameter was included in the authorization request as described in <a href="#authorization-request" class="xref">Section 4.1.1</a>, and their values MUST be identical.</dd>
<dt>"client_id":</dt>
<dd style="margin-left: 8">REQUIRED, if the client is not authenticating with the authorization server as described in <a href="#token-endpoint-client-authentication" class="xref">Section 3.2.1</a>.</dd>
<dt>"code_verifier":</dt>
<dd style="margin-left: 8">REQUIRED.  Code verifier</dd>
</dl>
<p id="rfc.section.4.1.3.p.3">If the client type is confidential or the client was issued client credentials (or assigned other authentication requirements), the client MUST authenticate with the authorization server as described in <a href="#token-endpoint-client-authentication" class="xref">Section 3.2.1</a>.</p>
<p id="rfc.section.4.1.3.p.4">For example, the client makes the following HTTP request using TLS (with extra line breaks for display purposes only):</p>
<pre>
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
&amp;code_verifier=3641a2d12d66101249cdf7a79c000c1f8c05d2aafcf14bf146497bed
</pre>
<p id="rfc.section.4.1.3.p.5">The authorization server MUST:</p>
<p></p>

<ul>
<li>require client authentication for confidential clients or for any client that was issued client credentials (or with other authentication requirements),</li>
<li>authenticate the client if client authentication is included,</li>
<li>ensure that the authorization code was issued to the authenticated confidential client, or if the client is public, ensure that the code was issued to "client_id" in the request,</li>
<li>verify that the authorization code is valid,</li>
<li>verify the "code_verifier" by calculating the code challenge from the received "code_verifier" and comparing it with the previously associated "code_challenge", after first transforming it according to the "code_challenge_method" method specified by the client, and</li>
<li>ensure that the "redirect_uri" parameter is present if the "redirect_uri" parameter was included in the initial authorization request as described in <a href="#authorization-request" class="xref">Section 4.1.1</a>, and if included ensure that their values are identical.</li>
</ul>
<h1 id="rfc.section.4.1.4">
<a href="#rfc.section.4.1.4">4.1.4.</a> <a href="#authorization-code-access-token-response" id="authorization-code-access-token-response">Access Token Response</a>
</h1>
<p id="rfc.section.4.1.4.p.1">If the access token request is valid and authorized, the authorization server issues an access token and optional refresh token as described in <a href="#access-token-successful-response" class="xref">Section 5.1</a>.  If the request client authentication failed or is invalid, the authorization server returns an error response as described in <a href="#access-token-error-response" class="xref">Section 5.2</a>.</p>
<p id="rfc.section.4.1.4.p.2">An example successful response:</p>
<pre>
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token": "2YotnFZFEjr1zCsicMWpAA",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter": "example_value"
}
</pre>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#client-credentials-grant" id="client-credentials-grant">Client Credentials Grant</a>
</h1>
<p id="rfc.section.4.2.p.1">The client can request an access token using only its client credentials (or other supported means of authentication) when the client is requesting access to the protected resources under its control, or those of another resource owner that have been previously arranged with the authorization server (the method of which is beyond the scope of this specification).</p>
<p id="rfc.section.4.2.p.2">The client credentials grant type MUST only be used by confidential clients.</p>
<div id="rfc.figure.4"></div>
<div id="fig-client-credentials-flow"></div>
<pre>
     +---------+                                  +---------------+
     |         |                                  |               |
     |         |&gt;--(A)- Client Authentication ---&gt;| Authorization |
     | Client  |                                  |     Server    |
     |         |&lt;--(B)---- Access Token ---------&lt;|               |
     |         |                                  |               |
     +---------+                                  +---------------+
</pre>
<p class="figure">Figure 4: Client Credentials Flow</p>
<p id="rfc.section.4.2.p.3">The flow illustrated in <a href="#fig-client-credentials-flow" class="xref">Figure 4</a> includes the following steps:</p>
<p id="rfc.section.4.2.p.4">(A)  The client authenticates with the authorization server and requests an access token from the token endpoint.</p>
<p id="rfc.section.4.2.p.5">(B)  The authorization server authenticates the client, and if valid, issues an access token.</p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#authorization-request-and-response" id="authorization-request-and-response">Authorization Request and Response</a>
</h1>
<p id="rfc.section.4.2.1.p.1">Since the client authentication is used as the authorization grant, no additional authorization request is needed.</p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#client-credentials-access-token-request" id="client-credentials-access-token-request">Access Token Request</a>
</h1>
<p id="rfc.section.4.2.2.p.1">The client makes a request to the token endpoint by adding the following parameters using the "application/x-www-form-urlencoded" format per Appendix B with a character encoding of UTF-8 in the HTTP request entity-body:</p>
<p></p>

<dl>
<dt>"grant_type":</dt>
<dd style="margin-left: 8">REQUIRED.  Value MUST be set to "client_credentials".</dd>
<dt>"scope":</dt>
<dd style="margin-left: 8">OPTIONAL.  The scope of the access request as described by <a href="#access-token-scope" class="xref">Section 3.3</a>.</dd>
</dl>
<p id="rfc.section.4.2.2.p.3">The client MUST authenticate with the authorization server as described in <a href="#token-endpoint-client-authentication" class="xref">Section 3.2.1</a>.</p>
<p id="rfc.section.4.2.2.p.4">For example, the client makes the following HTTP request using transport-layer security (with extra line breaks for display purposes only):</p>
<pre>
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
</pre>
<p id="rfc.section.4.2.2.p.5">The authorization server MUST authenticate the client.</p>
<h1 id="rfc.section.4.2.3">
<a href="#rfc.section.4.2.3">4.2.3.</a> <a href="#access-token-response" id="access-token-response">Access Token Response</a>
</h1>
<p id="rfc.section.4.2.3.p.1">If the access token request is valid and authorized, the authorization server issues an access token as described in <a href="#access-token-successful-response" class="xref">Section 5.1</a>.  A refresh token SHOULD NOT be included.  If the request failed client authentication or is invalid, the authorization server returns an error response as described in <a href="#access-token-error-response" class="xref">Section 5.2</a>.</p>
<p id="rfc.section.4.2.3.p.2">An example successful response:</p>
<pre>
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token": "2YotnFZFEjr1zCsicMWpAA",
  "token_type": "Bearer",
  "expires_in": 3600,
  "example_parameter": "example_value"
}
</pre>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#extension-grants" id="extension-grants">Extension Grants</a>
</h1>
<p id="rfc.section.4.3.p.1">The client uses an extension grant type by specifying the grant type using an absolute URI (defined by the authorization server) as the value of the "grant_type" parameter of the token endpoint, and by adding any additional parameters necessary.</p>
<p id="rfc.section.4.3.p.2">For example, to request an access token using a Security Assertion Markup Language (SAML) 2.0 assertion grant type as defined by <a href="#RFC7522" class="xref">[RFC7522]</a>, the client could make the following HTTP request using TLS (with extra line breaks for display purposes only):</p>
<pre>
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-
bearer&amp;assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU
[...omitted for brevity...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-
</pre>
<p id="rfc.section.4.3.p.3">If the access token request is valid and authorized, the authorization server issues an access token and optional refresh token as described in <a href="#access-token-successful-response" class="xref">Section 5.1</a>.  If the request failed client authentication or is invalid, the authorization server returns an error response as described in <a href="#access-token-error-response" class="xref">Section 5.2</a>.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#issuing-an-access-token" id="issuing-an-access-token">Issuing an Access Token</a>
</h1>
<p id="rfc.section.5.p.1">If the access token request is valid and authorized, the authorization server issues an access token and optional refresh token as described in <a href="#access-token-successful-response" class="xref">Section 5.1</a>.  If the request failed client authentication or is invalid, the authorization server returns an error response as described in <a href="#access-token-error-response" class="xref">Section 5.2</a>.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#access-token-successful-response" id="access-token-successful-response">Successful Response</a>
</h1>
<p id="rfc.section.5.1.p.1">The authorization server issues an access token and optional refresh token, and constructs the response by adding the following parameters to the entity-body of the HTTP response with a 200 (OK) status code:</p>
<p></p>

<dl>
<dt>"access_token":</dt>
<dd style="margin-left: 8">REQUIRED.  The access token issued by the authorization server.</dd>
<dt>"token_type":</dt>
<dd style="margin-left: 8">REQUIRED.  The type of the token issued as described in <a href="#access-token-types" class="xref">Section 7.1</a>.  Value is case insensitive.</dd>
<dt>"expires_in":</dt>
<dd style="margin-left: 8">RECOMMENDED.  The lifetime in seconds of the access token.  For example, the value "3600" denotes that the access token will expire in one hour from the time the response was generated.  If omitted, the authorization server SHOULD provide the expiration time via other means or document the default value.</dd>
<dt>"refresh_token":</dt>
<dd style="margin-left: 8">OPTIONAL.  The refresh token, which can be used to obtain new access tokens using the same authorization grant as described in <a href="#refreshing-an-access-token" class="xref">Section 6</a>.</dd>
<dt>"scope":</dt>
<dd style="margin-left: 8">OPTIONAL, if identical to the scope requested by the client; otherwise, REQUIRED.  The scope of the access token as described by <a href="#access-token-scope" class="xref">Section 3.3</a>.</dd>
</dl>
<p id="rfc.section.5.1.p.3">The parameters are included in the entity-body of the HTTP response using the "application/json" media type as defined by <a href="#RFC4627" class="xref">[RFC4627]</a>.  The parameters are serialized into a JavaScript Object Notation (JSON) structure by adding each parameter at the highest structure level.  Parameter names and string values are included as JSON strings.  Numerical values are included as JSON numbers.  The order of parameters does not matter and can vary.</p>
<p id="rfc.section.5.1.p.4">The authorization server MUST include the HTTP "Cache-Control" response header field <a href="#RFC2616" class="xref">[RFC2616]</a> with a value of "no-store" in any response containing tokens, credentials, or other sensitive information, as well as the "Pragma" response header field <a href="#RFC2616" class="xref">[RFC2616]</a> with a value of "no-cache".</p>
<p id="rfc.section.5.1.p.5">For example:</p>
<pre>
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"Bearer",
  "expires_in":3600,
  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter":"example_value"
}
</pre>
<p id="rfc.section.5.1.p.6">The client MUST ignore unrecognized value names in the response.  The sizes of tokens and other values received from the authorization server are left undefined.  The client should avoid making assumptions about value sizes.  The authorization server SHOULD document the size of any value it issues.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#access-token-error-response" id="access-token-error-response">Error Response</a>
</h1>
<p id="rfc.section.5.2.p.1">The authorization server responds with an HTTP 400 (Bad Request) status code (unless specified otherwise) and includes the following parameters with the response:</p>
<p id="rfc.section.5.2.p.2">The authorization server responds with an HTTP 400 (Bad Request) status code (unless specified otherwise) and includes the following parameters with the response:</p>
<p></p>

<dl>
<dt>"error":</dt>
<dd style="margin-left: 8">REQUIRED.  A single ASCII <a href="#USASCII" class="xref">[USASCII]</a> error code from the following: <dl>
<dt>"invalid_request":</dt>
<dd style="margin-left: 8">The request is missing a required parameter, includes an unsupported parameter value (other than grant type), repeats a parameter, includes multiple credentials, utilizes more than one mechanism for authenticating the client, or is otherwise malformed.</dd>
<dt>"invalid_client":</dt>
<dd style="margin-left: 8">Client authentication failed (e.g., unknown client, no client authentication included, or unsupported authentication method).  The authorization server MAY return an HTTP 401 (Unauthorized) status code to indicate which HTTP authentication schemes are supported.  If the client attempted to authenticate via the "Authorization" request header field, the authorization server MUST respond with an HTTP 401 (Unauthorized) status code and include the "WWW-Authenticate" response header field matching the authentication scheme used by the client.</dd>
<dt>"invalid_grant":</dt>
<dd style="margin-left: 8">The provided authorization grant (e.g., authorization code, resource owner credentials) or refresh token is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client.</dd>
<dt>"unauthorized_client":</dt>
<dd style="margin-left: 8">The authenticated client is not authorized to use this authorization grant type.</dd>
<dt>"unsupported_grant_type":</dt>
<dd style="margin-left: 8">The authorization grant type is not supported by the authorization server.</dd>
<dt>"invalid_scope":</dt>
<dd style="margin-left: 8">The requested scope is invalid, unknown, malformed, or exceeds the scope granted by the resource owner.</dd>
</dl>
<p> Values for the "error" parameter MUST NOT include characters outside the set %x20-21 / %x23-5B / %x5D-7E.</p>
</dd>
<dt>"error_description":</dt>
<dd style="margin-left: 8">OPTIONAL.  Human-readable ASCII <a href="#USASCII" class="xref">[USASCII]</a> text providing additional information, used to assist the client developer in understanding the error that occurred.  Values for the "error_description" parameter MUST NOT include characters outside the set %x20-21 / %x23-5B / %x5D-7E.</dd>
<dt>"error_uri":</dt>
<dd style="margin-left: 8">OPTIONAL.  A URI identifying a human-readable web page with information about the error, used to provide the client developer with additional information about the error.  Values for the "error_uri" parameter MUST conform to the URI-reference syntax and thus MUST NOT include characters outside the set %x21 / %x23-5B / %x5D-7E.</dd>
</dl>
<p id="rfc.section.5.2.p.4">The parameters are included in the entity-body of the HTTP response using the "application/json" media type as defined by <a href="#RFC4627" class="xref">[RFC4627]</a>.  The parameters are serialized into a JSON structure by adding each parameter at the highest structure level.  Parameter names and string values are included as JSON strings.  Numerical values are included as JSON numbers.  The order of parameters does not matter and can vary.</p>
<p id="rfc.section.5.2.p.5">For example:</p>
<pre>
HTTP/1.1 400 Bad Request
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
 "error":"invalid_request"
}
</pre>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#refreshing-an-access-token" id="refreshing-an-access-token">Refreshing an Access Token</a>
</h1>
<p id="rfc.section.6.p.1">Authorization servers SHOULD determine, based on a risk assessment, whether to issue refresh tokens to a certain client.  If the authorization server decides not to issue refresh tokens, the client MAY refresh access tokens by utilizing other grant types, such as the authorization code grant type.  In such a case, the authorization server may utilize cookies and persistent grants to optimize the user experience.</p>
<p id="rfc.section.6.p.2">If refresh tokens are issued, those refresh tokens MUST be bound to the scope and resource servers as consented by the resource owner.  This is to prevent privilege escalation by the legitimate client and reduce the impact of refresh token leakage.</p>
<p id="rfc.section.6.p.3">If the authorization server issued a refresh token to the client, the client makes a refresh request to the token endpoint by adding the following parameters using the "application/x-www-form-urlencoded" format per Appendix B with a character encoding of UTF-8 in the HTTP request entity-body:</p>
<p></p>

<dl>
<dt>"grant_type":</dt>
<dd style="margin-left: 8">REQUIRED.  Value MUST be set to "refresh_token".</dd>
<dt>"refresh_token":</dt>
<dd style="margin-left: 8">REQUIRED.  The refresh token issued to the client.</dd>
<dt>"scope":</dt>
<dd style="margin-left: 8">OPTIONAL.  The scope of the access request as described by <a href="#access-token-scope" class="xref">Section 3.3</a>.  The requested scope MUST NOT include any scope not originally granted by the resource owner, and if omitted is treated as equal to the scope originally granted by the resource owner.</dd>
</dl>
<p id="rfc.section.6.p.5">Because refresh tokens are typically long-lasting credentials used to request additional access tokens, the refresh token is bound to the client to which it was issued.  If the client type is confidential or the client was issued client credentials (or assigned other authentication requirements), the client MUST authenticate with the authorization server as described in <a href="#token-endpoint-client-authentication" class="xref">Section 3.2.1</a>.</p>
<p id="rfc.section.6.p.6">For example, the client makes the following HTTP request using transport-layer security (with extra line breaks for display purposes only):</p>
<pre>
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
</pre>
<p id="rfc.section.6.p.7">The authorization server MUST:</p>
<p></p>

<ul>
<li>require client authentication for confidential clients or for any client that was issued client credentials (or with other authentication requirements),</li>
<li>authenticate the client if client authentication is included and ensure that the refresh token was issued to the authenticated client, and</li>
<li>validate the refresh token.</li>
</ul>
<p id="rfc.section.6.p.9">Authorization server MUST utilize one of these methods to detect refresh token replay by malicious actors for public clients:</p>
<p></p>

<ul>
<li>
<em>Sender-constrained refresh tokens:</em> the authorization server cryptographically binds the refresh token to a certain client instance by utilizing <a href="#I-D.ietf-oauth-token-binding" class="xref">[I-D.ietf-oauth-token-binding]</a> or <a href="#RFC8705" class="xref">[RFC8705]</a>.</li>
<li>
<em>Refresh token rotation:</em> the authorization server issues a new refresh token with every access token refresh response.  The previous refresh token is invalidated but information about the relationship is retained by the authorization server.  If a refresh token is compromised and subsequently used by both the attacker and the legitimate client, one of them will present an invalidated refresh token, which will inform the authorization server of the breach.  The authorization server cannot determine which party submitted the invalid refresh token, but it will revoke the active refresh token.  This stops the attack at the cost of forcing the legitimate client to obtain a fresh authorization grant.  <br><br> Implementation note: the grant to which a refresh token belongs may be encoded into the refresh token itself.  This can enable an authorization server to efficiently determine the grant to which a refresh token belongs, and by extension, all refresh tokens that need to be revoked.  Authorization servers MUST ensure the integrity of the refresh token value in this case, for example, using signatures.</li>
</ul>
<p id="rfc.section.6.p.11">If valid and authorized, the authorization server issues an access token as described in <a href="#access-token-successful-response" class="xref">Section 5.1</a>.  If the request failed verification or is invalid, the authorization server returns an error response as described in <a href="#access-token-error-response" class="xref">Section 5.2</a>.</p>
<p id="rfc.section.6.p.12">The authorization server MAY issue a new refresh token, in which case the client MUST discard the old refresh token and replace it with the new refresh token.  The authorization server MAY revoke the old refresh token after issuing a new refresh token to the client.  If a new refresh token is issued, the refresh token scope MUST be identical to that of the refresh token included by the client in the request.</p>
<p id="rfc.section.6.p.13">Authorization servers MAY revoke refresh tokens automatically in case of a security event, such as:</p>
<p></p>

<ul>
<li>password change</li>
<li>logout at the authorization server</li>
</ul>
<p id="rfc.section.6.p.15">Refresh tokens SHOULD expire if the client has been inactive for some time, i.e., the refresh token has not been used to obtain fresh access tokens for some time.  The expiration time is at the discretion of the authorization server.  It might be a global value or determined based on the client policy or the grant associated with the refresh token (and its sensitivity).</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#accessing-protected-resources" id="accessing-protected-resources">Accessing Protected Resources</a>
</h1>
<p id="rfc.section.7.p.1">The client accesses protected resources by presenting the access token to the resource server.  The resource server MUST validate the access token and ensure that it has not expired and that its scope covers the requested resource.  The methods used by the resource server to validate the access token (as well as any error responses) are beyond the scope of this specification but generally involve an interaction or coordination between the resource server and the authorization server.</p>
<p id="rfc.section.7.p.2">The method in which the client utilizes the access token to authenticate with the resource server depends on the type of access token issued by the authorization server.  Typically, it involves using the HTTP "Authorization" request header field <a href="#RFC2617" class="xref">[RFC2617]</a> with an authentication scheme defined by the specification of the access token type used, such as "Bearer", defined below.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#access-token-types" id="access-token-types">Access Token Types</a>
</h1>
<p id="rfc.section.7.1.p.1">The access token type provides the client with the information required to successfully utilize the access token to make a protected resource request (along with type-specific attributes).  The client MUST NOT use an access token if it does not understand the token type.</p>
<p id="rfc.section.7.1.p.2">For example, the "Bearer" token type defined in this specification is utilized by simply including the access token string in the request:</p>
<pre>
GET /resource/1 HTTP/1.1
Host: example.com
Authorization: Bearer mF_9.B5f-4.1JqM
</pre>
<p id="rfc.section.7.1.p.3">The above example is provided for illustration purposes only.</p>
<p id="rfc.section.7.1.p.4">Each access token type definition specifies the additional attributes (if any) sent to the client together with the "access_token" response parameter.  It also defines the HTTP authentication method used to include the access token when making a protected resource request.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#bearer-tokens" id="bearer-tokens">Bearer Tokens</a>
</h1>
<p id="rfc.section.7.2.p.1">A Bearer Token is a security token with the property that any party in possession of the token (a "bearer") can use the token in any way that any other party in possession of it can.  Using a bearer token does not require a bearer to prove possession of cryptographic key material (proof-of-possession).</p>
<p id="rfc.section.7.2.p.2">Bearer tokens may be extended to include proof-of-possession techniques by other specifications.</p>
<h1 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> <a href="#authenticated-requests" id="authenticated-requests">Authenticated Requests</a>
</h1>
<p id="rfc.section.7.2.1.p.1">This section defines two methods of sending Bearer tokens in resource requetss to resource servers. Clients MUST NOT use more than one method to transmit the token in each request.</p>
<h1 id="rfc.section.7.2.1.1">
<a href="#rfc.section.7.2.1.1">7.2.1.1.</a> <a href="#authorization-request-header-field" id="authorization-request-header-field">Authorization Request Header Field</a>
</h1>
<p id="rfc.section.7.2.1.1.p.1">When sending the access token in the "Authorization" request header field defined by HTTP/1.1 <a href="#RFC2617" class="xref">[RFC2617]</a>, the client uses the "Bearer" authentication scheme to transmit the access token.</p>
<p id="rfc.section.7.2.1.1.p.2">For example:</p>
<pre>
 GET /resource HTTP/1.1
 Host: server.example.com
 Authorization: Bearer mF_9.B5f-4.1JqM
</pre>
<p id="rfc.section.7.2.1.1.p.3">The syntax of the "Authorization" header field for this scheme follows the usage of the Basic scheme defined in Section 2 of <a href="#RFC2617" class="xref">[RFC2617]</a>.  Note that, as with Basic, it does not conform to the generic syntax defined in Section 1.2 of <a href="#RFC2617" class="xref">[RFC2617]</a> but is compatible with the general authentication framework being developed for HTTP 1.1 <a href="#HTTP-AUTH" class="xref">[HTTP-AUTH]</a>, although it does not follow the preferred practice outlined therein in order to reflect existing deployments.  The syntax for Bearer credentials is as follows:</p>
<pre>
b64token    = 1*( ALPHA / DIGIT /
                 "-" / "." / "_" / "~" / "+" / "/" ) *"="
credentials = "Bearer" 1*SP b64token
</pre>
<p id="rfc.section.7.2.1.1.p.4">Clients SHOULD make authenticated requests with a bearer token using the "Authorization" request header field with the "Bearer" HTTP authorization scheme.  Resource servers MUST support this method.</p>
<h1 id="rfc.section.7.2.1.2">
<a href="#rfc.section.7.2.1.2">7.2.1.2.</a> <a href="#form-encoded-body-parameter" id="form-encoded-body-parameter">Form-Encoded Body Parameter</a>
</h1>
<p id="rfc.section.7.2.1.2.p.1">When sending the access token in the HTTP request entity-body, the client adds the access token to the request-body using the "access_token" parameter.  The client MUST NOT use this method unless all of the following conditions are met:</p>
<p></p>

<ul>
<li>The HTTP request entity-header includes the "Content-Type" header field set to "application/x-www-form-urlencoded".</li>
<li>The entity-body follows the encoding requirements of the "application/x-www-form-urlencoded" content-type as defined by HTML 4.01 <a href="#W3C.REC-html401-19991224" class="xref">[W3C.REC-html401-19991224]</a>.</li>
<li>The HTTP request entity-body is single-part.</li>
<li>The content to be encoded in the entity-body MUST consist entirely of ASCII <a href="#USASCII" class="xref">[USASCII]</a> characters.</li>
<li>The HTTP request method is one for which the request-body has defined semantics.  In particular, this means that the "GET" method MUST NOT be used.</li>
</ul>
<p id="rfc.section.7.2.1.2.p.3">The entity-body MAY include other request-specific parameters, in which case the "access_token" parameter MUST be properly separated from the request-specific parameters using "&amp;" character(s) (ASCII code 38).</p>
<p id="rfc.section.7.2.1.2.p.4">For example, the client makes the following HTTP request using transport-layer security:</p>
<pre>
POST /resource HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

access_token=mF_9.B5f-4.1JqM
</pre>
<p id="rfc.section.7.2.1.2.p.5">The "application/x-www-form-urlencoded" method SHOULD NOT be used except in application contexts where participating clients do not have access to the "Authorization" request header field.  Resource servers MAY support this method.</p>
<h1 id="rfc.section.7.2.2">
<a href="#rfc.section.7.2.2">7.2.2.</a> <a href="#the-www-authenticate-response-header-field" id="the-www-authenticate-response-header-field">The WWW-Authenticate Response Header Field</a>
</h1>
<p id="rfc.section.7.2.2.p.1">If the protected resource request does not include authentication credentials or does not contain an access token that enables access to the protected resource, the resource server MUST include the HTTP "WWW-Authenticate" response header field; it MAY include it in response to other conditions as well.  The "WWW-Authenticate" header field uses the framework defined by HTTP/1.1 <a href="#RFC2617" class="xref">[RFC2617]</a>.</p>
<p id="rfc.section.7.2.2.p.2">All challenges defined by this specification MUST use the auth-scheme value "Bearer".  This scheme MUST be followed by one or more auth-param values.  The auth-param attributes used or defined by this specification are as follows.  Other auth-param attributes MAY be used as well.</p>
<p id="rfc.section.7.2.2.p.3">A "realm" attribute MAY be included to indicate the scope of protection in the manner described in HTTP/1.1 <a href="#RFC2617" class="xref">[RFC2617]</a>.  The "realm" attribute MUST NOT appear more than once.</p>
<p id="rfc.section.7.2.2.p.4">The "scope" attribute is defined in <a href="#access-token-scope" class="xref">Section 3.3</a>.  The "scope" attribute is a space-delimited list of case-sensitive scope values indicating the required scope of the access token for accessing the requested resource. "scope" values are implementation defined; there is no centralized registry for them; allowed values are defined by the authorization server.  The order of "scope" values is not significant.  In some cases, the "scope" value will be used when requesting a new access token with sufficient scope of access to utilize the protected resource.  Use of the "scope" attribute is OPTIONAL.  The "scope" attribute MUST NOT appear more than once.  The "scope" value is intended for programmatic use and is not meant to be displayed to end-users.</p>
<p id="rfc.section.7.2.2.p.5">Two example scope values follow; these are taken from the OpenID Connect <a href="#OpenID.Messages" class="xref">[OpenID.Messages]</a> and the Open Authentication Technology Committee (OATC) Online Multimedia Authorization Protocol <a href="#OMAP" class="xref">[OMAP]</a> OAuth 2.0 use cases, respectively:</p>
<pre>
scope="openid profile email"
scope="urn:example:channel=HBO&amp;urn:example:rating=G,PG-13"
</pre>
<p id="rfc.section.7.2.2.p.6">If the protected resource request included an access token and failed authentication, the resource server SHOULD include the "error" attribute to provide the client with the reason why the access request was declined.  The parameter value is described in <a href="#bearer-token-error-codes" class="xref">Section 7.3.1</a>.  In addition, the resource server MAY include the "error_description" attribute to provide developers a human-readable explanation that is not meant to be displayed to end-users.  It also MAY include the "error_uri" attribute with an absolute URI identifying a human-readable web page explaining the error.  The "error", "error_description", and "error_uri" attributes MUST NOT appear more than once.</p>
<p id="rfc.section.7.2.2.p.7">Values for the "scope" attribute (specified in Appendix A.4) MUST NOT include characters outside the set %x21 / %x23-5B / %x5D-7E for representing scope values and %x20 for delimiters between scope values.  Values for the "error" and "error_description" attributes (specified in Appendixes A.7 and A.8) MUST NOT include characters outside the set %x20-21 / %x23-5B / %x5D-7E.  Values for the "error_uri" attribute (specified in Appendix A.9 of) MUST conform to the URI-reference syntax and thus MUST NOT include characters outside the set %x21 / %x23-5B / %x5D-7E.</p>
<p id="rfc.section.7.2.2.p.8">For example, in response to a protected resource request without authentication:</p>
<pre>
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="example"
</pre>
<p id="rfc.section.7.2.2.p.9">And in response to a protected resource request with an authentication attempt using an expired access token:</p>
<pre>
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="example",
                  error="invalid_token",
                  error_description="The access token expired"
</pre>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#bearer-token-error-response" id="bearer-token-error-response">Error Response</a>
</h1>
<p id="rfc.section.7.3.p.1">If a resource access request fails, the resource server SHOULD inform the client of the error.  While the specifics of such error responses are beyond the scope of this specification, this document establishes a common registry in <a href="#error-registry" class="xref">Section 11.4</a> for error values to be shared among OAuth token authentication schemes.</p>
<p id="rfc.section.7.3.p.2">New authentication schemes designed primarily for OAuth token authentication SHOULD define a mechanism for providing an error status code to the client, in which the error values allowed are registered in the error registry established by this specification.</p>
<p id="rfc.section.7.3.p.3">Such schemes MAY limit the set of valid error codes to a subset of the registered values.  If the error code is returned using a named parameter, the parameter name SHOULD be "error".</p>
<p id="rfc.section.7.3.p.4">Other schemes capable of being used for OAuth token authentication, but not primarily designed for that purpose, MAY bind their error values to the registry in the same manner.</p>
<p id="rfc.section.7.3.p.5">New authentication schemes MAY choose to also specify the use of the "error_description" and "error_uri" parameters to return error information in a manner parallel to their usage in this specification.</p>
<h1 id="rfc.section.7.3.1">
<a href="#rfc.section.7.3.1">7.3.1.</a> <a href="#bearer-token-error-codes" id="bearer-token-error-codes">Error Codes</a>
</h1>
<p id="rfc.section.7.3.1.p.1">When a request fails, the resource server responds using the appropriate HTTP status code (typically, 400, 401, 403, or 405) and includes one of the following error codes in the response:</p>
<p></p>

<dl>
<dt>"invalid_request":</dt>
<dd style="margin-left: 8">The request is missing a required parameter, includes an unsupported parameter or parameter value, repeats the same parameter, uses more than one method for including an access token, or is otherwise malformed.  The resource server SHOULD respond with the HTTP 400 (Bad Request) status code.</dd>
<dt>"invalid_token":</dt>
<dd style="margin-left: 8">The access token provided is expired, revoked, malformed, or invalid for other reasons.  The resource SHOULD respond with the HTTP 401 (Unauthorized) status code.  The client MAY request a new access token and retry the protected resource request.</dd>
<dt>"insufficient_scope":</dt>
<dd style="margin-left: 8">The request requires higher privileges than provided by the access token.  The resource server SHOULD respond with the HTTP 403 (Forbidden) status code and MAY include the "scope" attribute with the scope necessary to access the protected resource.</dd>
</dl>
<p id="rfc.section.7.3.1.p.3">If the request lacks any authentication information (e.g., the client was unaware that authentication is necessary or attempted using an unsupported authentication method), the resource server SHOULD NOT include an error code or other error information.</p>
<p id="rfc.section.7.3.1.p.4">For example:</p>
<pre>
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="example"
</pre>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#access-token-security-considerations" id="access-token-security-considerations">Access Token Security Considerations</a>
</h1>
<h1 id="rfc.section.7.4.1">
<a href="#rfc.section.7.4.1">7.4.1.</a> <a href="#security-threats" id="security-threats">Security Threats</a>
</h1>
<p id="rfc.section.7.4.1.p.1">The following list presents several common threats against protocols utilizing some form of tokens.  This list of threats is based on NIST Special Publication 800-63 <a href="#NIST800-63" class="xref">[NIST800-63]</a>.</p>
<h1 id="rfc.section.7.4.1.1">
<a href="#rfc.section.7.4.1.1">7.4.1.1.</a> <a href="#token-manufacturemodification" id="token-manufacturemodification">Token manufacture/modification</a>
</h1>
<p id="rfc.section.7.4.1.1.p.1">An attacker may generate a bogus token or modify the token contents (such as the authentication or attribute statements) of an existing token, causing the resource server to grant inappropriate access to the client.  For example, an attacker may modify the token to extend the validity period; a malicious client may modify the assertion to gain access to information that they should not be able to view.</p>
<h1 id="rfc.section.7.4.1.2">
<a href="#rfc.section.7.4.1.2">7.4.1.2.</a> <a href="#token-disclosure" id="token-disclosure">Token disclosure</a>
</h1>
<p id="rfc.section.7.4.1.2.p.1">Tokens may contain authentication and attribute statements that include sensitive information.</p>
<h1 id="rfc.section.7.4.1.3">
<a href="#rfc.section.7.4.1.3">7.4.1.3.</a> <a href="#token-redirect" id="token-redirect">Token redirect</a>
</h1>
<p id="rfc.section.7.4.1.3.p.1">An attacker uses a token generated for consumption by one resource server to gain access to a different resource server that mistakenly believes the token to be for it.</p>
<h1 id="rfc.section.7.4.1.4">
<a href="#rfc.section.7.4.1.4">7.4.1.4.</a> <a href="#token-replay" id="token-replay">Token replay</a>
</h1>
<p id="rfc.section.7.4.1.4.p.1">An attacker attempts to use a token that has already been used with that resource server in the past.</p>
<h1 id="rfc.section.7.4.2">
<a href="#rfc.section.7.4.2">7.4.2.</a> <a href="#threat-mitigation" id="threat-mitigation">Threat Mitigation</a>
</h1>
<p id="rfc.section.7.4.2.p.1">A large range of threats can be mitigated by protecting the contents of the token by using a digital signature.  Alternatively, a bearer token can contain a reference to authorization information, rather than encoding the information directly.  Such references MUST be infeasible for an attacker to guess; using a reference may require an extra interaction between a server and the token issuer to resolve the reference to the authorization information.  The mechanics of such an interaction are not defined by this specification.</p>
<p id="rfc.section.7.4.2.p.2">This document does not specify the encoding or the contents of the token; hence, detailed recommendations about the means of guaranteeing token integrity protection are outside the scope of this document.  The token integrity protection MUST be sufficient to prevent the token from being modified.</p>
<p id="rfc.section.7.4.2.p.3">To deal with token redirect, it is important for the authorization server to include the identity of the intended recipients (the audience), typically a single resource server (or a list of resource servers), in the token.  Restricting the use of the token to a specific scope is also RECOMMENDED.</p>
<p id="rfc.section.7.4.2.p.4">The authorization server MUST implement TLS.  Which version(s) ought to be implemented will vary over time and will depend on the widespread deployment and known security vulnerabilities at the time of implementation.</p>
<p id="rfc.section.7.4.2.p.5">To protect against token disclosure, confidentiality protection MUST be applied using TLS with a ciphersuite that provides confidentiality and integrity protection.  This requires that the communication interaction between the client and the authorization server, as well as the interaction between the client and the resource server, utilize confidentiality and integrity protection.  Since TLS is mandatory to implement and to use with this specification, it is the preferred approach for preventing token disclosure via the communication channel.  For those cases where the client is prevented from observing the contents of the token, token encryption MUST be applied in addition to the usage of TLS protection.  As a further defense against token disclosure, the client MUST validate the TLS certificate chain when making requests to protected resources, including checking the Certificate Revocation List (CRL) <a href="#RFC5280" class="xref">[RFC5280]</a>.</p>
<p id="rfc.section.7.4.2.p.6">Cookies are typically transmitted in the clear.  Thus, any information contained in them is at risk of disclosure.  Therefore, Bearer tokens MUST NOT be stored in cookies that can be sent in the clear, as any information in them is at risk of disclosure.  See "HTTP State Management Mechanism" <a href="#RFC6265" class="xref">[RFC6265]</a> for security considerations about cookies.</p>
<p id="rfc.section.7.4.2.p.7">In some deployments, including those utilizing load balancers, the TLS connection to the resource server terminates prior to the actual server that provides the resource.  This could leave the token unprotected between the front-end server where the TLS connection terminates and the back-end server that provides the resource.  In such deployments, sufficient measures MUST be employed to ensure confidentiality of the token between the front-end and back-end servers; encryption of the token is one such possible measure.</p>
<p id="rfc.section.7.4.2.p.8">To deal with token capture and replay, the following recommendations are made: First, the lifetime of the token MUST be limited; one means of achieving this is by putting a validity time field inside the protected part of the token.  Note that using short-lived (one hour or less) tokens reduces the impact of them being leaked.  Second, confidentiality protection of the exchanges between the client and the authorization server and between the client and the resource server MUST be applied.  As a consequence, no eavesdropper along the communication path is able to observe the token exchange.  Consequently, such an on-path adversary cannot replay the token.  Furthermore, when presenting the token to a resource server, the client MUST verify the identity of that resource server, as per Section 3.1 of "HTTP Over TLS" <a href="#RFC2818" class="xref">[RFC2818]</a>.  Note that the client MUST validate the TLS certificate chain when making these requests to protected resources.  Presenting the token to an unauthenticated and unauthorized resource server or failing to validate the certificate chain will allow adversaries to steal the token and gain unauthorized access to protected resources.</p>
<h1 id="rfc.section.7.4.3">
<a href="#rfc.section.7.4.3">7.4.3.</a> <a href="#summary-of-recommendations" id="summary-of-recommendations">Summary of Recommendations</a>
</h1>
<h1 id="rfc.section.7.4.3.1">
<a href="#rfc.section.7.4.3.1">7.4.3.1.</a> <a href="#safeguard-bearer-tokens" id="safeguard-bearer-tokens">Safeguard bearer tokens</a>
</h1>
<p id="rfc.section.7.4.3.1.p.1">Client implementations MUST ensure that bearer tokens are not leaked to unintended parties, as they will be able to use them to gain access to protected resources.  This is the primary security consideration when using bearer tokens and underlies all the more specific recommendations that follow.</p>
<h1 id="rfc.section.7.4.3.2">
<a href="#rfc.section.7.4.3.2">7.4.3.2.</a> <a href="#validate-tls-certificate-chains" id="validate-tls-certificate-chains">Validate TLS certificate chains</a>
</h1>
<p id="rfc.section.7.4.3.2.p.1">The client MUST validate the TLS certificate chain when making requests to protected resources.  Failing to do so may enable DNS hijacking attacks to steal the token and gain unintended access.</p>
<h1 id="rfc.section.7.4.3.3">
<a href="#rfc.section.7.4.3.3">7.4.3.3.</a> <a href="#always-use-tls-https" id="always-use-tls-https">Always use TLS (https)</a>
</h1>
<p id="rfc.section.7.4.3.3.p.1">Clients MUST always use TLS (https) or equivalent transport security when making requests with bearer tokens.  Failing to do so exposes the token to numerous attacks that could give attackers unintended access.</p>
<h1 id="rfc.section.7.4.3.4">
<a href="#rfc.section.7.4.3.4">7.4.3.4.</a> <a href="#dont-store-bearer-tokens-in-http-cookies" id="dont-store-bearer-tokens-in-http-cookies">Don't store bearer tokens in HTTP cookies</a>
</h1>
<p id="rfc.section.7.4.3.4.p.1">Implementations MUST NOT store bearer tokens within cookies that can be sent in the clear (which is the default transmission mode for cookies).  Implementations that do store bearer tokens in cookies MUST take precautions against cross-site request forgery.</p>
<h1 id="rfc.section.7.4.3.5">
<a href="#rfc.section.7.4.3.5">7.4.3.5.</a> <a href="#issue-short-lived-bearer-tokens" id="issue-short-lived-bearer-tokens">Issue short-lived bearer tokens</a>
</h1>
<p id="rfc.section.7.4.3.5.p.1">Token servers SHOULD issue short-lived (one hour or less) bearer tokens, particularly when issuing tokens to clients that run within a web browser or other environments where information leakage may occur.  Using short-lived bearer tokens can reduce the impact of them being leaked.</p>
<h1 id="rfc.section.7.4.3.6">
<a href="#rfc.section.7.4.3.6">7.4.3.6.</a> <a href="#issue-scoped-bearer-tokens" id="issue-scoped-bearer-tokens">Issue scoped bearer tokens</a>
</h1>
<p id="rfc.section.7.4.3.6.p.1">Token servers SHOULD issue bearer tokens that contain an audience restriction, scoping their use to the intended relying party or set of relying parties.</p>
<h1 id="rfc.section.7.4.3.7">
<a href="#rfc.section.7.4.3.7">7.4.3.7.</a> <a href="#dont-pass-bearer-tokens-in-page-urls" id="dont-pass-bearer-tokens-in-page-urls">Don't pass bearer tokens in page URLs</a>
</h1>
<p id="rfc.section.7.4.3.7.p.1">Bearer tokens MUST NOT be passed in page URLs (for example, as query string parameters).  Instead, bearer tokens SHOULD be passed in HTTP message headers or message bodies for which confidentiality measures are taken.  Browsers, web servers, and other software may not adequately secure URLs in the browser history, web server logs, and other data structures.  If bearer tokens are passed in page URLs, attackers might be able to steal them from the history data, logs, or other unsecured locations.</p>
<h1 id="rfc.section.7.4.4">
<a href="#rfc.section.7.4.4">7.4.4.</a> <a href="#token-replay-prevention" id="token-replay-prevention">Token Replay Prevention</a>
</h1>
<p id="rfc.section.7.4.4.p.1">A sender-constrained access token scopes the applicability of an access token to a certain sender.  This sender is obliged to demonstrate knowledge of a certain secret as prerequisite for the acceptance of that token at the recipient (e.g., a resource server).</p>
<p id="rfc.section.7.4.4.p.2">Authorization and resource servers SHOULD use mechanisms for sender- constrained access tokens to prevent token replay as described in Section 4.8.1.1.2 of <a href="#I-D.ietf-oauth-security-topics" class="xref">[I-D.ietf-oauth-security-topics]</a>.  The use of Mutual TLS for OAuth 2.0 <a href="#RFC8705" class="xref">[RFC8705]</a> is RECOMMENDED.</p>
<p id="rfc.section.7.4.4.p.3">It is RECOMMENDED to use end-to-end TLS.  If TLS traffic needs to be terminated at an intermediary, refer to Section 4.11 of <a href="#I-D.ietf-oauth-security-topics" class="xref">[I-D.ietf-oauth-security-topics]</a> for further security advice.</p>
<h1 id="rfc.section.7.4.5">
<a href="#rfc.section.7.4.5">7.4.5.</a> <a href="#access-token-privilege-restriction" id="access-token-privilege-restriction">Access Token Privilege Restriction</a>
</h1>
<p id="rfc.section.7.4.5.p.1">The privileges associated with an access token SHOULD be restricted to the minimum required for the particular application or use case.  This prevents clients from exceeding the privileges authorized by the resource owner.  It also prevents users from exceeding their privileges authorized by the respective security policy.  Privilege restrictions also help to reduce the impact of access token leakage.</p>
<p id="rfc.section.7.4.5.p.2">In particular, access tokens SHOULD be restricted to certain resource servers (audience restriction), preferably to a single resource server.  To put this into effect, the authorization server associates the access token with certain resource servers and every resource server is obliged to verify, for every request, whether the access token sent with that request was meant to be used for that particular resource server.  If not, the resource server MUST refuse to serve the respective request.  Clients and authorization servers MAY utilize the parameters "scope" or "resource" as specified in this document and <a href="#I-D.ietf-oauth-resource-indicators" class="xref">[I-D.ietf-oauth-resource-indicators]</a>, respectively, to determine the resource server they want to access.</p>
<p id="rfc.section.7.4.5.p.3">Additionally, access tokens SHOULD be restricted to certain resources and actions on resource servers or resources.  To put this into effect, the authorization server associates the access token with the respective resource and actions and every resource server is obliged to verify, for every request, whether the access token sent with that request was meant to be used for that particular action on the particular resource.  If not, the resource server must refuse to serve the respective request.  Clients and authorization servers MAY utilize the parameter "scope" and "authorization_details" as specified in <a href="#I-D.ietf-oauth-rar" class="xref">[I-D.ietf-oauth-rar]</a> to determine those resources and/or actions.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#extensibility" id="extensibility">Extensibility</a>
</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#defining-access-token-types" id="defining-access-token-types">Defining Access Token Types</a>
</h1>
<p id="rfc.section.8.1.p.1">Access token types can be defined in one of two ways: registered in the Access Token Types registry (following the procedures in <a href="#access-token-registry" class="xref">Section 11.1</a>), or by using a unique absolute URI as its name.</p>
<p id="rfc.section.8.1.p.2">Types utilizing a URI name SHOULD be limited to vendor-specific implementations that are not commonly applicable, and are specific to the implementation details of the resource server where they are used.</p>
<p id="rfc.section.8.1.p.3">All other types MUST be registered.  Type names MUST conform to the type-name ABNF.  If the type definition includes a new HTTP authentication scheme, the type name SHOULD be identical to the HTTP authentication scheme name (as defined by <a href="#RFC2617" class="xref">[RFC2617]</a>).  The token type "example" is reserved for use in examples.</p>
<pre>
type-name  = 1*name-char
name-char  = "-" / "." / "_" / DIGIT / ALPHA
</pre>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#defining-new-endpoint-parameters" id="defining-new-endpoint-parameters">Defining New Endpoint Parameters</a>
</h1>
<p id="rfc.section.8.2.p.1">New request or response parameters for use with the authorization endpoint or the token endpoint are defined and registered in the OAuth Parameters registry following the procedure in <a href="#parameters-registry" class="xref">Section 11.2</a>.</p>
<p id="rfc.section.8.2.p.2">Parameter names MUST conform to the param-name ABNF, and parameter values syntax MUST be well-defined (e.g., using ABNF, or a reference to the syntax of an existing parameter).</p>
<pre>
param-name  = 1*name-char
name-char   = "-" / "." / "_" / DIGIT / ALPHA
</pre>
<p id="rfc.section.8.2.p.3">Unregistered vendor-specific parameter extensions that are not commonly applicable and that are specific to the implementation details of the authorization server where they are used SHOULD utilize a vendor-specific prefix that is not likely to conflict with other registered values (e.g., begin with 'companyname_').</p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#defining-new-authorization-grant-types" id="defining-new-authorization-grant-types">Defining New Authorization Grant Types</a>
</h1>
<p id="rfc.section.8.3.p.1">New authorization grant types can be defined by assigning them a unique absolute URI for use with the "grant_type" parameter.  If the extension grant type requires additional token endpoint parameters, they MUST be registered in the OAuth Parameters registry as described by <a href="#parameters-registry" class="xref">Section 11.2</a>.</p>
<h1 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> <a href="#new-response-types" id="new-response-types">Defining New Authorization Endpoint Response Types</a>
</h1>
<p id="rfc.section.8.4.p.1">New response types for use with the authorization endpoint are defined and registered in the Authorization Endpoint Response Types registry following the procedure in <a href="#response-types-registry" class="xref">Section 11.3</a>.  Response type names MUST conform to the response-type ABNF.</p>
<pre>
response-type  = response-name *( SP response-name )
response-name  = 1*response-char
response-char  = "_" / DIGIT / ALPHA
</pre>
<p id="rfc.section.8.4.p.2">If a response type contains one or more space characters (%x20), it is compared as a space-delimited list of values in which the order of values does not matter.  Only one order of values can be registered, which covers all other arrangements of the same set of values.</p>
<p id="rfc.section.8.4.p.3">For example, the response type "token code" is left undefined by this specification.  However, an extension can define and register the "token code" response type.  Once registered, the same combination cannot be registered as "code token", but both values can be used to denote the same response type.</p>
<h1 id="rfc.section.8.5">
<a href="#rfc.section.8.5">8.5.</a> <a href="#defining-additional-error-codes" id="defining-additional-error-codes">Defining Additional Error Codes</a>
</h1>
<p id="rfc.section.8.5.p.1">In cases where protocol extensions (i.e., access token types, extension parameters, or extension grant types) require additional error codes to be used with the authorization code grant error response (<a href="#authorization-code-error-response" class="xref">Section 4.1.2.1</a>), the token error response (<a href="#access-token-error-response" class="xref">Section 5.2</a>), or the resource access error response (<a href="#bearer-token-error-response" class="xref">Section 7.3</a>), such error codes MAY be defined.</p>
<p id="rfc.section.8.5.p.2">Extension error codes MUST be registered (following the procedures in <a href="#error-registry" class="xref">Section 11.4</a>) if the extension they are used in conjunction with is a registered access token type, a registered endpoint parameter, or an extension grant type.  Error codes used with unregistered extensions MAY be registered.</p>
<p id="rfc.section.8.5.p.3">Error codes MUST conform to the error ABNF and SHOULD be prefixed by an identifying name when possible.  For example, an error identifying an invalid value set to the extension parameter "example" SHOULD be named "example_invalid".</p>
<pre>
error      = 1*error-char
error-char = %x20-21 / %x23-5B / %x5D-7E
</pre>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#native-applications" id="native-applications">Native Applications</a>
</h1>
<p id="rfc.section.9.p.1">Native applications are clients installed and executed on the device used by the resource owner (i.e., desktop application, native mobile application).  Native applications require special consideration related to security, platform capabilities, and overall end-user experience.</p>
<p id="rfc.section.9.p.2">The authorization endpoint requires interaction between the client and the resource owner's user-agent. The best current practice is to perform the OAuth authorization request in an external user-agent (typically the browser) rather than an embedded user-agent (such as one implemented with web-views).</p>
<p id="rfc.section.9.p.3">The native application can capture the response from the authorization server using a redirection URI with a scheme registered with the operating system to invoke the client as the handler, manual copy-and-paste of the credentials, running a local web server, installing a user-agent extension, or by providing a redirection URI identifying a server-hosted resource under the client's control, which in turn makes the response available to the native application.</p>
<p id="rfc.section.9.p.4">Previously, it was common for native apps to use embedded user-agents (commonly implemented with web-views) for OAuth authorization requests.  That approach has many drawbacks, including the host app being able to copy user credentials and cookies as well as the user needing to authenticate from scratch in each app.  See <a href="#native-apps-embedded-user-agents" class="xref">Section 10.19</a> for a deeper analysis of the drawbacks of using embedded user-agents for OAuth.</p>
<p id="rfc.section.9.p.5">Native app authorization requests that use the browser are more secure and can take advantage of the user's authentication state.  Being able to use the existing authentication session in the browser enables single sign-on, as users don't need to authenticate to the authorization server each time they use a new app (unless required by the authorization server policy).</p>
<p id="rfc.section.9.p.6">Supporting authorization flows between a native app and the browser is possible without changing the OAuth protocol itself, as the OAuth authorization request and response are already defined in terms of URIs.  This encompasses URIs that can be used for inter-app communication.  Some OAuth server implementations that assume all clients are confidential web clients will need to add an understanding of public native app clients and the types of redirect URIs they use to support this best practice.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#authorization-flow-for-native-apps-using-the-browser" id="authorization-flow-for-native-apps-using-the-browser">Authorization Flow for Native Apps Using the Browser</a>
</h1>
<div id="rfc.figure.5"></div>
<div id="fig-native-app-authorization-flow"></div>
<pre>
  +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
  |          User Device          |
  |                               |
  | +--------------------------+  | (5) Authorization  +---------------+
  | |                          |  |     Code           |               |
  | |        Client App        |----------------------&gt;|     Token     |
  | |                          |&lt;----------------------|    Endpoint   |
  | +--------------------------+  | (6) Access Token,  |               |
  |   |             ^             |     Refresh Token  +---------------+
  |   |             |             |
  |   |             |             |
  |   | (1)         | (4)         |
  |   | Authorizat- | Authoriza-  |
  |   | ion Request | tion Code   |
  |   |             |             |
  |   |             |             |
  |   v             |             |
  | +---------------------------+ | (2) Authorization  +---------------+
  | |                           | |     Request        |               |
  | |          Browser          |---------------------&gt;| Authorization |
  | |                           |&lt;---------------------|    Endpoint   |
  | +---------------------------+ | (3) Authorization  |               |
  |                               |     Code           +---------------+
  +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
</pre>
<p class="figure">Figure 5: Native App Authorization via an External User-Agent</p>
<p><a href="#fig-native-app-authorization-flow" class="xref">Figure 5</a> illustrates the interaction between a native app and the browser to authorize the user.</p>
<p></p>

<ol>
<li>Client app opens a browser tab with the authorization request.</li>
<li>Authorization endpoint receives the authorization request, authenticates the user, and obtains authorization.  Authenticating the user may involve chaining to other authentication systems.</li>
<li>Authorization server issues an authorization code to the redirect URI.</li>
<li>Client receives the authorization code from the redirect URI.</li>
<li>Client app presents the authorization code at the token endpoint.</li>
<li>Token endpoint validates the authorization code and issues the tokens requested.</li>
</ol>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#using-inter-app-uri-communication-for-oauth-in-native-apps" id="using-inter-app-uri-communication-for-oauth-in-native-apps">Using Inter-App URI Communication for OAuth in Native Apps</a>
</h1>
<p id="rfc.section.9.2.p.1">Just as URIs are used for OAuth on the web to initiate the authorization request and return the authorization response to the requesting website, URIs can be used by native apps to initiate the authorization request in the device's browser and return the response to the requesting native app.</p>
<p id="rfc.section.9.2.p.2">By adopting the same methods used on the web for OAuth, benefits seen in the web context like the usability of a single sign-on session and the security of a separate authentication context are likewise gained in the native app context.  Reusing the same approach also reduces the implementation complexity and increases interoperability by relying on standards-based web flows that are not specific to a particular platform.</p>
<p id="rfc.section.9.2.p.3">Native apps MUST use an external user-agent to perform OAuth authorization requests.  This is achieved by opening the authorization request in the browser (detailed in <a href="#authorization-request-native-app" class="xref">Section 9.3</a>) and using a redirect URI that will return the authorization response back to the native app (defined in <a href="#authorization-response-native-app" class="xref">Section 9.4</a>).</p>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#authorization-request-native-app" id="authorization-request-native-app">Initiating the Authorization Request from a Native App</a>
</h1>
<p id="rfc.section.9.3.p.1">Native apps needing user authorization create an authorization request URI with the authorization code grant type per <a href="#authorization-code-grant" class="xref">Section 4.1</a> using a redirect URI capable of being received by the native app.</p>
<p id="rfc.section.9.3.p.2">The function of the redirect URI for a native app authorization request is similar to that of a web-based authorization request.  Rather than returning the authorization response to the OAuth client's server, the redirect URI used by a native app returns the response to the app.  Several options for a redirect URI that will return the authorization response to the native app in different platforms are documented in <a href="#authorization-response-native-app" class="xref">Section 9.4</a>.  Any redirect URI that allows the app to receive the URI and inspect its parameters is viable.</p>
<p id="rfc.section.9.3.p.3">After constructing the authorization request URI, the app uses platform-specific APIs to open the URI in an external user-agent.  Typically, the external user-agent used is the default browser, that is, the application configured for handling "http" and "https" scheme URIs on the system; however, different browser selection criteria and other categories of external user-agents MAY be used.</p>
<p id="rfc.section.9.3.p.4">This best practice focuses on the browser as the RECOMMENDED external user-agent for native apps.  An external user-agent designed specifically for user authorization and capable of processing authorization requests and responses like a browser MAY also be used.  Other external user-agents, such as a native app provided by the authorization server may meet the criteria set out in this best practice, including using the same redirection URI properties, but their use is out of scope for this specification.</p>
<p id="rfc.section.9.3.p.5">Some platforms support a browser feature known as "in-app browser tabs", where an app can present a tab of the browser within the app context without switching apps, but still retain key benefits of the browser such as a shared authentication state and security context.  On platforms where they are supported, it is RECOMMENDED, for usability reasons, that apps use in-app browser tabs for the authorization request.</p>
<h1 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> <a href="#authorization-response-native-app" id="authorization-response-native-app">Receiving the Authorization Response in a Native App</a>
</h1>
<p id="rfc.section.9.4.p.1">There are several redirect URI options available to native apps for receiving the authorization response from the browser, the availability and user experience of which varies by platform.</p>
<p id="rfc.section.9.4.p.2">To fully support native apps, authorization servers MUST offer at least the three redirect URI options described in the following subsections to native apps.  Native apps MAY use whichever redirect option suits their needs best, taking into account platform-specific implementation details.</p>
<h1 id="rfc.section.9.4.1">
<a href="#rfc.section.9.4.1">9.4.1.</a> <a href="#private-use-uri-scheme" id="private-use-uri-scheme">Private-Use URI Scheme Redirection</a>
</h1>
<p id="rfc.section.9.4.1.p.1">Many mobile and desktop computing platforms support inter-app communication via URIs by allowing apps to register private-use URI schemes (sometimes colloquially referred to as "custom URL schemes") like <samp>com.example.app</samp>.  When the browser or another app attempts to load a URI with a private-use URI scheme, the app that registered it is launched to handle the request.</p>
<p id="rfc.section.9.4.1.p.2">To perform an authorization request with a private-use URI scheme redirect, the native app launches the browser with a standard authorization request, but one where the redirection URI utilizes a private-use URI scheme it registered with the operating system.</p>
<p id="rfc.section.9.4.1.p.3">When choosing a URI scheme to associate with the app, apps MUST use a URI scheme based on a domain name under their control, expressed in reverse order, as recommended by Section 3.8 of <a href="#RFC7595" class="xref">[RFC7595]</a> for private-use URI schemes.</p>
<p id="rfc.section.9.4.1.p.4">For example, an app that controls the domain name <samp>app.example.com</samp> can use <samp>com.example.app</samp> as their scheme.  Some authorization servers assign client identifiers based on domain names, for example, <samp>client1234.usercontent.example.net</samp>, which can also be used as the domain name for the scheme when reversed in the same manner.  A scheme such as <samp>myapp</samp>, however, would not meet this requirement, as it is not based on a domain name.</p>
<p id="rfc.section.9.4.1.p.5">When there are multiple apps by the same publisher, care must be taken so that each scheme is unique within that group.  On platforms that use app identifiers based on reverse-order domain names, those identifiers can be reused as the private-use URI scheme for the OAuth redirect to help avoid this problem.</p>
<p id="rfc.section.9.4.1.p.6">Following the requirements of Section 3.2 of <a href="#RFC3986" class="xref">[RFC3986]</a>, as there is no naming authority for private-use URI scheme redirects, only a single slash (<samp>/</samp>) appears after the scheme component.  A complete example of a redirect URI utilizing a private-use URI scheme is:</p>
<pre>
com.example.app:/oauth2redirect/example-provider
</pre>
<p id="rfc.section.9.4.1.p.7">When the authorization server completes the request, it redirects to the client's redirection URI as it would normally.  As the redirection URI uses a private-use URI scheme, it results in the operating system launching the native app, passing in the URI as a launch parameter.  Then, the native app uses normal processing for the authorization response.</p>
<h1 id="rfc.section.9.4.2">
<a href="#rfc.section.9.4.2">9.4.2.</a> <a href="#claimed-https-scheme-uri-redirection" id="claimed-https-scheme-uri-redirection">Claimed "https" Scheme URI Redirection</a>
</h1>
<p id="rfc.section.9.4.2.p.1">Some operating systems allow apps to claim <samp>https</samp> scheme <a href="#RFC7230" class="xref">[RFC7230]</a> URIs in the domains they control.  When the browser encounters a claimed URI, instead of the page being loaded in the browser, the native app is launched with the URI supplied as a launch parameter.</p>
<p id="rfc.section.9.4.2.p.2">Such URIs can be used as redirect URIs by native apps.  They are indistinguishable to the authorization server from a regular web- based client redirect URI.  An example is:</p>
<pre>
https://app.example.com/oauth2redirect/example-provider
</pre>
<p id="rfc.section.9.4.2.p.3">As the redirect URI alone is not enough to distinguish public native app clients from confidential web clients, it is REQUIRED in <a href="#native-app-registration" class="xref">Section 10.2</a> that the client type be recorded during client registration to enable the server to determine the client type and act accordingly.</p>
<p id="rfc.section.9.4.2.p.4">App-claimed <samp>https</samp> scheme redirect URIs have some advantages compared to other native app redirect options in that the identity of the destination app is guaranteed to the authorization server by the operating system.  For this reason, native apps SHOULD use them over the other options where possible.</p>
<h1 id="rfc.section.9.4.3">
<a href="#rfc.section.9.4.3">9.4.3.</a> <a href="#loopback-interface-redirection" id="loopback-interface-redirection">Loopback Interface Redirection</a>
</h1>
<p id="rfc.section.9.4.3.p.1">Native apps that are able to open a port on the loopback network interface without needing special permissions (typically, those on desktop operating systems) can use the loopback interface to receive the OAuth redirect.</p>
<p id="rfc.section.9.4.3.p.2">Loopback redirect URIs use the <samp>http</samp> scheme and are constructed with the loopback IP literal and whatever port the client is listening on.</p>
<p id="rfc.section.9.4.3.p.3">That is, <samp>http://127.0.0.1:{port}/{path}</samp> for IPv4, and <samp>http://[::1]:{port}/{path}</samp> for IPv6.  An example redirect using the IPv4 loopback interface with a randomly assigned port:</p>
<pre>
http://127.0.0.1:51004/oauth2redirect/example-provider
</pre>
<p id="rfc.section.9.4.3.p.4">An example redirect using the IPv6 loopback interface with a randomly assigned port:</p>
<pre>
http://[::1]:61023/oauth2redirect/example-provider
</pre>
<p id="rfc.section.9.4.3.p.5">The authorization server MUST allow any port to be specified at the time of the request for loopback IP redirect URIs, to accommodate clients that obtain an available ephemeral port from the operating system at the time of the request.</p>
<p id="rfc.section.9.4.3.p.6">Clients SHOULD NOT assume that the device supports a particular version of the Internet Protocol.  It is RECOMMENDED that clients attempt to bind to the loopback interface using both IPv4 and IPv6 and use whichever is available.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.10.p.1">As a flexible and extensible framework, OAuth's security considerations depend on many factors.  The following sections provide implementers with security guidelines focused on the three client profiles described in <a href="#client-types" class="xref">Section 2.1</a>: web application, browser-based application, and native application.</p>
<p id="rfc.section.10.p.2">A comprehensive OAuth security model and analysis, as well as background for the protocol design, is provided by <a href="#RFC6819" class="xref">[RFC6819]</a> and <a href="#I-D.ietf-oauth-security-topics" class="xref">[I-D.ietf-oauth-security-topics]</a>.</p>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#security-client-authentication" id="security-client-authentication">Client Authentication</a>
</h1>
<p id="rfc.section.10.1.p.1">Authorization servers SHOULD use client authentication if possible.</p>
<p id="rfc.section.10.1.p.2">It is RECOMMENDED to use asymmetric (public-key based) methods for client authentication such as mTLS <a href="#RFC8705" class="xref">[RFC8705]</a> or <samp>private_key_jwt</samp> <a href="#OpenID" class="xref">[OpenID]</a>. When asymmetric methods for client authentication are used, authorization servers do not need to store sensitive symmetric keys, making these methods more robust against a number of attacks.</p>
<p id="rfc.section.10.1.p.3">Authorization server MUST only rely on client authentication if the process of issuance/registration and distribution of the underlying credentials ensures their confidentiality.</p>
<p id="rfc.section.10.1.p.4">When client authentication is not possible, the authorization server SHOULD employ other means to validate the client's identity &#8211; for example, by requiring the registration of the client redirection URI or enlisting the resource owner to confirm identity.  A valid redirection URI is not sufficient to verify the client's identity when asking for resource owner authorization but can be used to prevent delivering credentials to a counterfeit client after obtaining resource owner authorization.</p>
<p id="rfc.section.10.1.p.5">The authorization server must consider the security implications of interacting with unauthenticated clients and take measures to limit the potential exposure of other credentials (e.g., refresh tokens) issued to such clients.</p>
<p id="rfc.section.10.1.p.6">The privileges an authorization server associates with a certain client identity MUST depend on the assessment of the overall process for client identification and client credential lifecycle management.  For example, authentication of a dynamically registered client just ensures the authorization server it is talking to the same client again.  In contrast, if there is a web application whose developer's identity was verified, who signed a contract and is issued a client secret that is only used in a secure backend service, the authorization server might allow this client to access more sensible services or to use the client credential grant type.</p>
<h1 id="rfc.section.10.1.1">
<a href="#rfc.section.10.1.1">10.1.1.</a> <a href="#client-authentication-of-native-apps" id="client-authentication-of-native-apps">Client Authentication of Native Apps</a>
</h1>
<p id="rfc.section.10.1.1.p.1">Secrets that are statically included as part of an app distributed to multiple users should not be treated as confidential secrets, as one user may inspect their copy and learn the shared secret.  For this reason, it is NOT RECOMMENDED for authorization servers to require client authentication of public native apps clients using a shared secret, as this serves little value beyond client identification which is already provided by the <samp>client_id</samp> request parameter.</p>
<p id="rfc.section.10.1.1.p.2">Authorization servers that still require a statically included shared secret for native app clients MUST treat the client as a public client (as defined in <a href="#client-types" class="xref">Section 2.1</a>), and not accept the secret as proof of the client's identity.  Without additional measures, such clients are subject to client impersonation (see <a href="#native-app-client-impersonation" class="xref">Section 10.3.1</a>).</p>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> <a href="#native-app-registration" id="native-app-registration">Registration of Native App Clients</a>
</h1>
<p id="rfc.section.10.2.p.1">Except when using a mechanism like Dynamic Client Registration <a href="#RFC7591" class="xref">[RFC7591]</a> to provision per-instance secrets, native apps are classified as public clients, as defined in <a href="#client-types" class="xref">Section 2.1</a>; they MUST be registered with the authorization server as such.  Authorization servers MUST record the client type in the client registration details in order to identify and process requests accordingly.</p>
<p id="rfc.section.10.2.p.2">Authorization servers MUST require clients to register their complete redirect URI (including the path component) and reject authorization requests that specify a redirect URI that doesn't exactly match the one that was registered; the exception is loopback redirects, where an exact match is required except for the port URI component.</p>
<p id="rfc.section.10.2.p.3">For private-use URI scheme-based redirects, authorization servers SHOULD enforce the requirement in <a href="#private-use-uri-scheme" class="xref">Section 9.4.1</a> that clients use schemes that are reverse domain name based.  At a minimum, any private-use URI scheme that doesn't contain a period character (<samp>.</samp>) SHOULD be rejected.</p>
<p id="rfc.section.10.2.p.4">In addition to the collision-resistant properties, requiring a URI scheme based on a domain name that is under the control of the app can help to prove ownership in the event of a dispute where two apps claim the same private-use URI scheme (where one app is acting maliciously).  For example, if two apps claimed <samp>com.example.app</samp>, the owner of <samp>example.com</samp> could petition the app store operator to remove the counterfeit app.  Such a petition is harder to prove if a generic URI scheme was used.</p>
<p id="rfc.section.10.2.p.5">Authorization servers MAY request the inclusion of other platform- specific information, such as the app package or bundle name, or other information that may be useful for verifying the calling app's identity on operating systems that support such functions.</p>
<h1 id="rfc.section.10.3">
<a href="#rfc.section.10.3">10.3.</a> <a href="#client-impersonation" id="client-impersonation">Client Impersonation</a>
</h1>
<p id="rfc.section.10.3.p.1">A malicious client can impersonate another client and obtain access to protected resources if the impersonated client fails to, or is unable to, keep its client credentials confidential.</p>
<p id="rfc.section.10.3.p.2">The authorization server MUST authenticate the client whenever possible.  If the authorization server cannot authenticate the client due to the client's nature, the authorization server MUST require the registration of any redirection URI used for receiving authorization responses and SHOULD utilize other means to protect resource owners from such potentially malicious clients.  For example, the authorization server can engage the resource owner to assist in identifying the client and its origin.</p>
<p id="rfc.section.10.3.p.3">The authorization server SHOULD enforce explicit resource owner authentication and provide the resource owner with information about the client and the requested authorization scope and lifetime.  It is up to the resource owner to review the information in the context of the current client and to authorize or deny the request.</p>
<p id="rfc.section.10.3.p.4">The authorization server SHOULD NOT process repeated authorization requests automatically (without active resource owner interaction) without authenticating the client or relying on other measures to ensure that the repeated request comes from the original client and not an impersonator.</p>
<h1 id="rfc.section.10.3.1">
<a href="#rfc.section.10.3.1">10.3.1.</a> <a href="#native-app-client-impersonation" id="native-app-client-impersonation">Impersonation of Native Apps</a>
</h1>
<p id="rfc.section.10.3.1.p.1">As stated above, the authorization server SHOULD NOT process authorization requests automatically without user consent or interaction, except when the identity of the client can be assured.  This includes the case where the user has previously approved an authorization request for a given client id &#8211; unless the identity of the client can be proven, the request SHOULD be processed as if no previous request had been approved.</p>
<p id="rfc.section.10.3.1.p.2">Measures such as claimed <samp>https</samp> scheme redirects MAY be accepted by authorization servers as identity proof.  Some operating systems may offer alternative platform-specific identity features that MAY be accepted, as appropriate.</p>
<h1 id="rfc.section.10.4">
<a href="#rfc.section.10.4">10.4.</a> <a href="#access-tokens" id="access-tokens">Access Tokens</a>
</h1>
<p id="rfc.section.10.4.p.1">Access token credentials (as well as any confidential access token attributes) MUST be kept confidential in transit and storage, and only shared among the authorization server, the resource servers the access token is valid for, and the client to whom the access token is issued.  Access token credentials MUST only be transmitted using TLS as described in <a href="#tls-version" class="xref">Section 1.6</a> with server authentication as defined by <a href="#RFC2818" class="xref">[RFC2818]</a>.</p>
<p id="rfc.section.10.4.p.2">The authorization server MUST ensure that access tokens cannot be generated, modified, or guessed to produce valid access tokens by unauthorized parties.</p>
<h1 id="rfc.section.10.4.1">
<a href="#rfc.section.10.4.1">10.4.1.</a> <a href="#access-token-privilege-restriction-1" id="access-token-privilege-restriction-1">Access Token Privilege Restriction</a>
</h1>
<p id="rfc.section.10.4.1.p.1">The client SHOULD request access tokens with the minimal scope necessary.  The authorization server SHOULD take the client identity into account when choosing how to honor the requested scope and MAY issue an access token with less rights than requested.</p>
<p id="rfc.section.10.4.1.p.2">The privileges associated with an access token SHOULD be restricted to the minimum required for the particular application or use case. This prevents clients from exceeding the privileges authorized by the resource owner. It also prevents users from exceeding their privileges authorized by the respective security policy. Privilege restrictions also help to reduce the impact of access token leakage.</p>
<p id="rfc.section.10.4.1.p.3">In particular, access tokens SHOULD be restricted to certain resource servers (audience restriction), preferably to a single resource server. To put this into effect, the authorization server associates the access token with certain resource servers and every resource server is obliged to verify, for every request, whether the access token sent with that request was meant to be used for that particular resource server. If not, the resource server MUST refuse to serve the respective request. Clients and authorization servers MAY utilize the parameters <samp>scope</samp> or <samp>resource</samp> as specified in <a href="#RFC8707" class="xref">[RFC8707]</a>, respectively, to determine the resource server they want to access.</p>
<h1 id="rfc.section.10.4.2">
<a href="#rfc.section.10.4.2">10.4.2.</a> <a href="#access-token-replay-prevention" id="access-token-replay-prevention">Access Token Replay Prevention</a>
</h1>
<p id="rfc.section.10.4.2.p.1">Additionally, access tokens SHOULD be restricted to certain resources and actions on resource servers or resources. To put this into effect, the authorization server associates the access token with the respective resource and actions and every resource server is obliged to verify, for every request, whether the access token sent with that request was meant to be used for that particular action on the particular resource. If not, the resource server must refuse to serve the respective request. Clients and authorization servers MAY utilize the parameter <samp>scope</samp> and <samp>authorization_details</samp> as specified in <a href="#I-D.ietf-oauth-rar" class="xref">[I-D.ietf-oauth-rar]</a> to determine those resources and/or actions.</p>
<p id="rfc.section.10.4.2.p.2">Authorization and resource servers SHOULD use mechanisms for sender-constrained access tokens to prevent token replay as described in (#pop_tokens). A sender-constrained access token scopes the applicability of an access token to a certain sender. This sender is obliged to demonstrate knowledge of a certain secret as prerequisite for the acceptance of that token at the recipient (e.g., a resource server). The use of Mutual TLS for OAuth 2.0 <a href="#RFC8705" class="xref">[RFC8705]</a> is RECOMMENDED.</p>
<h1 id="rfc.section.10.5">
<a href="#rfc.section.10.5">10.5.</a> <a href="#refresh-tokens" id="refresh-tokens">Refresh Tokens</a>
</h1>
<p id="rfc.section.10.5.p.1">Authorization servers MAY issue refresh tokens to clients.</p>
<p id="rfc.section.10.5.p.2">Refresh tokens MUST be kept confidential in transit and storage, and shared only among the authorization server and the client to whom the refresh tokens were issued.  The authorization server MUST maintain the binding between a refresh token and the client to whom it was issued.  Refresh tokens MUST only be transmitted using TLS as described in <a href="#tls-version" class="xref">Section 1.6</a> with server authentication as defined by <a href="#RFC2818" class="xref">[RFC2818]</a>.</p>
<p id="rfc.section.10.5.p.3">The authorization server MUST verify the binding between the refresh token and client identity whenever the client identity can be authenticated.  When client authentication is not possible, the authorization server MUST issue sender-constrained refresh tokens or use refresh token rotation as described in (#refresh_token_protection).</p>
<p id="rfc.section.10.5.p.4">The authorization server MUST ensure that refresh tokens cannot be generated, modified, or guessed to produce valid refresh tokens by unauthorized parties.</p>
<h1 id="rfc.section.10.6">
<a href="#rfc.section.10.6">10.6.</a> <a href="#protecting-redirect-based-flows" id="protecting-redirect-based-flows">Protecting Redirect-Based Flows</a>
</h1>
<p id="rfc.section.10.6.p.1">When comparing client redirect URIs against pre-registered URIs, authorization servers MUST utilize exact string matching. This measure contributes to the prevention of leakage of authorization codes and access tokens (see (#insufficient_uri_validation)). It can also help to detect mix-up attacks (see (#mix_up)).</p>
<p id="rfc.section.10.6.p.2">Clients MUST NOT expose URLs that forward the user's browser to arbitrary URIs obtained from a query parameter ("open redirector").  Open redirectors can enable exfiltration of authorization codes and access tokens, see (#open_redirector_on_client).</p>
<p id="rfc.section.10.6.p.3">Clients MUST prevent Cross-Site Request Forgery (CSRF). In this context, CSRF refers to requests to the redirection endpoint that do not originate at the authorization server, but a malicious third party (see Section 4.4.1.8. of <a href="#RFC6819" class="xref">[RFC6819]</a> for details). Clients that have ensured that the authorization server supports PKCE MAY rely the CSRF protection provided by PKCE. In OpenID Connect flows, the <samp>nonce</samp> parameter provides CSRF protection. Otherwise, one-time use CSRF tokens carried in the <samp>state</samp> parameter that are securely bound to the user agent MUST be used for CSRF protection (see (#csrf_countermeasures)).</p>
<p id="rfc.section.10.6.p.4">In order to prevent mix-up attacks (see (#mix_up)), clients MUST only process redirect responses of the authorization server they sent the respective request to and from the same user agent this authorization request was initiated with. Clients MUST store the authorization server they sent an authorization request to and bind this information to the user agent and check that the authorization request was received from the correct authorization server. Clients MUST ensure that the subsequent token request, if applicable, is sent to the same authorization server. Clients SHOULD use distinct redirect URIs for each authorization server as a means to identify the authorization server a particular response came from.</p>
<p id="rfc.section.10.6.p.5">An AS that redirects a request potentially containing user credentials MUST avoid forwarding these user credentials accidentally (see (#redirect_307) for details).</p>
<h1 id="rfc.section.10.6.1">
<a href="#rfc.section.10.6.1">10.6.1.</a> <a href="#loopback-redirect-considerations-in-native-apps" id="loopback-redirect-considerations-in-native-apps">Loopback Redirect Considerations in Native Apps</a>
</h1>
<p id="rfc.section.10.6.1.p.1">Loopback interface redirect URIs use the <samp>http</samp> scheme (i.e., without Transport Layer Security (TLS)).  This is acceptable for loopback interface redirect URIs as the HTTP request never leaves the device.</p>
<p id="rfc.section.10.6.1.p.2">Clients should open the network port only when starting the authorization request and close it once the response is returned.</p>
<p id="rfc.section.10.6.1.p.3">Clients should listen on the loopback network interface only, in order to avoid interference by other network actors.</p>
<p id="rfc.section.10.6.1.p.4">While redirect URIs using localhost (i.e., <samp>http://localhost:{port}/{path}</samp>) function similarly to loopback IP redirects described in <a href="#loopback-interface-redirection" class="xref">Section 9.4.3</a>, the use of <samp>localhost</samp> is NOT RECOMMENDED.  Specifying a redirect URI with the loopback IP literal rather than <samp>localhost</samp> avoids inadvertently listening on network interfaces other than the loopback interface.  It is also less susceptible to client-side firewalls and misconfigured host name resolution on the user's device.</p>
<h1 id="rfc.section.10.7">
<a href="#rfc.section.10.7">10.7.</a> <a href="#authorization-codes" id="authorization-codes">Authorization Codes</a>
</h1>
<p id="rfc.section.10.7.p.1">The transmission of authorization codes MUST be made over a secure channel, and the client MUST require the use of TLS with its redirection URI if the URI identifies a network resource.  Since authorization codes are transmitted via user-agent redirections, they could potentially be disclosed through user-agent history and HTTP referrer headers.</p>
<p id="rfc.section.10.7.p.2">Authorization codes MUST be short lived and single-use.  If the authorization server observes multiple attempts to exchange an authorization code for an access token, the authorization server SHOULD attempt to revoke all refresh and access tokens already granted based on the compromised authorization code.</p>
<p id="rfc.section.10.7.p.3">If the client can be authenticated, the authorization servers MUST authenticate the client and ensure that the authorization code was issued to the same client.</p>
<p id="rfc.section.10.7.p.4">Clients MUST prevent injection (replay) of authorization codes into the authorization response by attackers. The use of PKCE is RECOMMENDED to this end. The OpenID Connect <samp>nonce</samp> parameter and ID Token Claim <a href="#OpenID" class="xref">[OpenID]</a> MAY be used as well. The PKCE challenge or OpenID Connect <samp>nonce</samp> MUST be transaction-specific and securely bound to the client and the user agent in which the transaction was started.</p>
<p id="rfc.section.10.7.p.5">Note: although PKCE so far was designed as a mechanism to protect native apps, this advice applies to all kinds of OAuth clients, including web applications.</p>
<p id="rfc.section.10.7.p.6">When using PKCE, clients SHOULD use PKCE code challenge methods that do not expose the PKCE verifier in the authorization request.  Otherwise, attackers that can read the authorization request (cf.  Attacker A4 in (#secmodel)) can break the security provided by PKCE. Currently, <samp>S256</samp> is the only such method.</p>
<p id="rfc.section.10.7.p.7">Authorization servers MUST support PKCE.</p>
<p id="rfc.section.10.7.p.8">Authorization servers MUST provide a way to detect their support for PKCE. To this end, they MUST either (a) publish the element <samp>code_challenge_methods_supported</samp> in their AS metadata (<a href="#RFC8418" class="xref">[RFC8418]</a>) containing the supported PKCE challenge methods (which can be used by the client to detect PKCE support) or (b) provide a deployment-specific way to ensure or determine PKCE support by the AS.</p>
<h1 id="rfc.section.10.8">
<a href="#rfc.section.10.8">10.8.</a> <a href="#request-confidentiality" id="request-confidentiality">Request Confidentiality</a>
</h1>
<p id="rfc.section.10.8.p.1">Access tokens, refresh tokens, authorization codes, and client credentials MUST NOT be transmitted in the clear.</p>
<p id="rfc.section.10.8.p.2">The "state" and "scope" parameters SHOULD NOT include sensitive client or resource owner information in plain text, as they can be transmitted over insecure channels or stored insecurely.</p>
<h1 id="rfc.section.10.9">
<a href="#rfc.section.10.9">10.9.</a> <a href="#ensuring-endpoint-authenticity" id="ensuring-endpoint-authenticity">Ensuring Endpoint Authenticity</a>
</h1>
<p id="rfc.section.10.9.p.1">In order to prevent man-in-the-middle attacks, the authorization server MUST require the use of TLS with server authentication as defined by <a href="#RFC2818" class="xref">[RFC2818]</a> for any request sent to the authorization and token endpoints.  The client MUST validate the authorization server's TLS certificate as defined by <a href="#RFC6125" class="xref">[RFC6125]</a> and in accordance with its requirements for server identity authentication.</p>
<h1 id="rfc.section.10.10">
<a href="#rfc.section.10.10">10.10.</a> <a href="#credentials-guessing-attacks" id="credentials-guessing-attacks">Credentials-Guessing Attacks</a>
</h1>
<p id="rfc.section.10.10.p.1">The authorization server MUST prevent attackers from guessing access tokens, authorization codes, refresh tokens, resource owner passwords, and client credentials.</p>
<p id="rfc.section.10.10.p.2">The probability of an attacker guessing generated tokens (and other credentials not intended for handling by end-users) MUST be less than or equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).</p>
<p id="rfc.section.10.10.p.3">The authorization server MUST utilize other means to protect credentials intended for end-user usage.</p>
<h1 id="rfc.section.10.11">
<a href="#rfc.section.10.11">10.11.</a> <a href="#phishing-attacks" id="phishing-attacks">Phishing Attacks</a>
</h1>
<p id="rfc.section.10.11.p.1">Wide deployment of this and similar protocols may cause end-users to become inured to the practice of being redirected to websites where they are asked to enter their passwords.  If end-users are not careful to verify the authenticity of these websites before entering their credentials, it will be possible for attackers to exploit this practice to steal resource owners' passwords.</p>
<p id="rfc.section.10.11.p.2">Service providers should attempt to educate end-users about the risks phishing attacks pose and should provide mechanisms that make it easy for end-users to confirm the authenticity of their sites.  Client developers should consider the security implications of how they interact with the user-agent (e.g., external, embedded), and the ability of the end-user to verify the authenticity of the authorization server.</p>
<p id="rfc.section.10.11.p.3">To reduce the risk of phishing attacks, the authorization servers MUST require the use of TLS on every endpoint used for end-user interaction.</p>
<h1 id="rfc.section.10.12">
<a href="#rfc.section.10.12">10.12.</a> <a href="#fake-external-user-agents-in-native-apps" id="fake-external-user-agents-in-native-apps">Fake External User-Agents in Native Apps</a>
</h1>
<p id="rfc.section.10.12.p.1">The native app that is initiating the authorization request has a large degree of control over the user interface and can potentially present a fake external user-agent, that is, an embedded user-agent made to appear as an external user-agent.</p>
<p id="rfc.section.10.12.p.2">When all good actors are using external user-agents, the advantage is that it is possible for security experts to detect bad actors, as anyone faking an external user-agent is provably bad.  On the other hand, if good and bad actors alike are using embedded user-agents, bad actors don't need to fake anything, making them harder to detect.  Once a malicious app is detected, it may be possible to use this knowledge to blacklist the app's signature in malware scanning software, take removal action (in the case of apps distributed by app stores) and other steps to reduce the impact and spread of the malicious app.</p>
<p id="rfc.section.10.12.p.3">Authorization servers can also directly protect against fake external user-agents by requiring an authentication factor only available to true external user-agents.</p>
<p id="rfc.section.10.12.p.4">Users who are particularly concerned about their security when using in-app browser tabs may also take the additional step of opening the request in the full browser from the in-app browser tab and complete the authorization there, as most implementations of the in-app browser tab pattern offer such functionality.</p>
<h1 id="rfc.section.10.13">
<a href="#rfc.section.10.13">10.13.</a> <a href="#malicious-external-user-agents-in-native-apps" id="malicious-external-user-agents-in-native-apps">Malicious External User-Agents in Native Apps</a>
</h1>
<p id="rfc.section.10.13.p.1">If a malicious app is able to configure itself as the default handler for <samp>https</samp> scheme URIs in the operating system, it will be able to intercept authorization requests that use the default browser and abuse this position of trust for malicious ends such as phishing the user.</p>
<p id="rfc.section.10.13.p.2">This attack is not confined to OAuth; a malicious app configured in this way would present a general and ongoing risk to the user beyond OAuth usage by native apps.  Many operating systems mitigate this issue by requiring an explicit user action to change the default handler for <samp>http</samp> and <samp>https</samp> scheme URIs.</p>
<h1 id="rfc.section.10.14">
<a href="#rfc.section.10.14">10.14.</a> <a href="#csrf_countermeasures" id="csrf_countermeasures">Cross-Site Request Forgery</a>
</h1>
<p id="rfc.section.10.14.p.1">An attacker might attempt to inject a request to the redirect URI of the legitimate client on the victim's device, e.g., to cause the client to access resources under the attacker's control. This is a variant of an attack known as Cross-Site Request Forgery (CSRF).</p>
<p id="rfc.section.10.14.p.2">The traditional countermeasure are CSRF tokens that are bound to the user agent and passed in the <samp>state</samp> parameter to the authorization server as described in <a href="#RFC6819" class="xref">[RFC6819]</a>. The same protection is provided by PKCE or the OpenID Connect <samp>nonce</samp> value.</p>
<p id="rfc.section.10.14.p.3">When using PKCE instead of <samp>state</samp> or <samp>nonce</samp> for CSRF protection, it is important to note that:</p>
<p></p>

<ul>
<li>Clients MUST ensure that the AS supports PKCE before using PKCE for CSRF protection. If an authorization server does not support PKCE, <samp>state</samp> or <samp>nonce</samp> MUST be used for CSRF protection.</li>
<li>If <samp>state</samp> is used for carrying application state, and integrity of its contents is a concern, clients MUST protect <samp>state</samp> against tampering and swapping. This can be achieved by binding the contents of state to the browser session and/or signed/encrypted state values <a href="#I-D.bradley-oauth-jwt-encoded-state" class="xref">[I-D.bradley-oauth-jwt-encoded-state]</a>.</li>
</ul>
<p id="rfc.section.10.14.p.5">AS therefore MUST provide a way to detect their support for PKCE either via AS metadata according to <a href="#RFC8414" class="xref">[RFC8414]</a> or provide a deployment-specific way to ensure or determine PKCE support.</p>
<h1 id="rfc.section.10.15">
<a href="#rfc.section.10.15">10.15.</a> <a href="#clickjacking" id="clickjacking">Clickjacking</a>
</h1>
<p id="rfc.section.10.15.p.1">As described in Section 4.4.1.9 of <a href="#RFC6819" class="xref">[RFC6819]</a>, the authorization request is susceptible to clickjacking. An attacker can use this vector to obtain the user's authentication credentials, change the scope of access granted to the client, and potentially access the user's resources.</p>
<p id="rfc.section.10.15.p.2">Authorization servers MUST prevent clickjacking attacks. Multiple countermeasures are described in <a href="#RFC6819" class="xref">[RFC6819]</a>, including the use of the X-Frame-Options HTTP response header field and frame-busting JavaScript. In addition to those, authorization servers SHOULD also use Content Security Policy (CSP) level 2 <a href="#CSP-2" class="xref">[CSP-2]</a> or greater.</p>
<p id="rfc.section.10.15.p.3">To be effective, CSP must be used on the authorization endpoint and, if applicable, other endpoints used to authenticate the user and authorize the client (e.g., the device authorization endpoint, login pages, error pages, etc.). This prevents framing by unauthorized origins in user agents that support CSP. The client MAY permit being framed by some other origin than the one used in its redirection endpoint. For this reason, authorization servers SHOULD allow administrators to configure allowed origins for particular clients and/or for clients to register these dynamically.</p>
<p id="rfc.section.10.15.p.4">Using CSP allows authorization servers to specify multiple origins in a single response header field and to constrain these using flexible patterns (see <a href="#CSP-2" class="xref">[CSP-2]</a> for details). Level 2 of this standard provides a robust mechanism for protecting against clickjacking by using policies that restrict the origin of frames (using <samp>frame-ancestors</samp>) together with those that restrict the sources of scripts allowed to execute on an HTML page (by using <samp>script-src</samp>). A non-normative example of such a policy is shown in the following listing:</p>
<p><samp>HTTP/1.1 200 OK Content-Security-Policy: frame-ancestors https://ext.example.org:8000 Content-Security-Policy: script-src 'self' X-Frame-Options: ALLOW-FROM https://ext.example.org:8000 ...  </samp></p>
<p id="rfc.section.10.15.p.6">Because some user agents do not support <a href="#CSP-2" class="xref">[CSP-2]</a>, this technique SHOULD be combined with others, including those described in <a href="#RFC6819" class="xref">[RFC6819]</a>, unless such legacy user agents are explicitly unsupported by the authorization server. Even in such cases, additional countermeasures SHOULD still be employed.</p>
<h1 id="rfc.section.10.16">
<a href="#rfc.section.10.16">10.16.</a> <a href="#code-injection-and-input-validation" id="code-injection-and-input-validation">Code Injection and Input Validation</a>
</h1>
<p id="rfc.section.10.16.p.1">A code injection attack occurs when an input or otherwise external variable is used by an application unsanitized and causes modification to the application logic.  This may allow an attacker to gain access to the application device or its data, cause denial of service, or introduce a wide range of malicious side-effects.</p>
<p id="rfc.section.10.16.p.2">The authorization server and client MUST sanitize (and validate when possible) any value received &#8211; in particular, the value of the "state" and "redirect_uri" parameters.</p>
<h1 id="rfc.section.10.17">
<a href="#rfc.section.10.17">10.17.</a> <a href="#open-redirectors" id="open-redirectors">Open Redirectors</a>
</h1>
<p id="rfc.section.10.17.p.1">The following attacks can occur when an AS or client has an open redirector. An open redirector is an endpoint that forwards a user's browser to an arbitrary URI obtained from a query parameter.</p>
<h1 id="rfc.section.10.17.1">
<a href="#rfc.section.10.17.1">10.17.1.</a> <a href="#open_redirector_on_client" id="open_redirector_on_client">Client as Open Redirector</a>
</h1>
<p id="rfc.section.10.17.1.p.1">Clients MUST NOT expose open redirectors. Attackers may use open redirectors to produce URLs pointing to the client and utilize them to exfiltrate authorization codes and access tokens, as described in (#redir_uri_open_redir). Another abuse case is to produce URLs that appear to point to the client. This might trick users into trusting the URL and follow it in their browser. This can be abused for phishing.</p>
<p id="rfc.section.10.17.1.p.2">In order to prevent open redirection, clients should only redirect if the target URLs are whitelisted or if the origin and integrity of a request can be authenticated. Countermeasures against open redirection are described by OWASP <a href="#owasp_redir" class="xref">[owasp_redir]</a>.</p>
<h1 id="rfc.section.10.17.2">
<a href="#rfc.section.10.17.2">10.17.2.</a> <a href="#authorization-server-as-open-redirector" id="authorization-server-as-open-redirector">Authorization Server as Open Redirector</a>
</h1>
<p id="rfc.section.10.17.2.p.1">Just as with clients, attackers could try to utilize a user's trust in the authorization server (and its URL in particular) for performing phishing attacks. OAuth authorization servers regularly redirect users to other web sites (the clients), but must do so in a safe way.</p>
<p><a href="#authorization-code-error-response" class="xref">Section 4.1.2.1</a> already prevents open redirects by stating that the AS MUST NOT automatically redirect the user agent in case of an invalid combination of <samp>client_id</samp> and <samp>redirect_uri</samp>.</p>
<p id="rfc.section.10.17.2.p.3">However, an attacker could also utilize a correctly registered redirect URI to perform phishing attacks. The attacker could, for example, register a client via dynamic client registration <a href="#RFC7591" class="xref">[RFC7591]</a> and intentionally send an erroneous authorization request, e.g., by using an invalid scope value, thus instructing the AS to redirect the user agent to its phishing site.</p>
<p id="rfc.section.10.17.2.p.4">The AS MUST take precautions to prevent this threat. Based on its risk assessment, the AS needs to decide whether it can trust the redirect URI and SHOULD only automatically redirect the user agent if it trusts the redirect URI. If the URI is not trusted, the AS MAY inform the user and rely on the user to make the correct decision.</p>
<h1 id="rfc.section.10.18">
<a href="#rfc.section.10.18">10.18.</a> <a href="#authorization-server-mix-up-mitigation-in-native-apps" id="authorization-server-mix-up-mitigation-in-native-apps">Authorization Server Mix-Up Mitigation in Native Apps</a>
</h1>
<p id="rfc.section.10.18.p.1">(TODO: merge this with the regular mix-up section when it is brought in)</p>
<p id="rfc.section.10.18.p.2">To protect against a compromised or malicious authorization server attacking another authorization server used by the same app, it is REQUIRED that a unique redirect URI is used for each authorization server used by the app (for example, by varying the path component), and that authorization responses are rejected if the redirect URI they were received on doesn't match the redirect URI in an outgoing authorization request.</p>
<p id="rfc.section.10.18.p.3">The native app MUST store the redirect URI used in the authorization request with the authorization session data (i.e., along with "state" and other related data) and MUST verify that the URI on which the authorization response was received exactly matches it.</p>
<p id="rfc.section.10.18.p.4">The requirement of <a href="#native-app-registration" class="xref">Section 10.2</a>, specifically that authorization servers reject requests with URIs that don't match what was registered, is also required to prevent such attacks.</p>
<h1 id="rfc.section.10.19">
<a href="#rfc.section.10.19">10.19.</a> <a href="#native-apps-embedded-user-agents" id="native-apps-embedded-user-agents">Embedded User Agents in Native Apps</a>
</h1>
<p id="rfc.section.10.19.p.1">Embedded user-agents are a technically possible method for authorizing native apps.  These embedded user-agents are unsafe for use by third parties to the authorization server by definition, as the app that hosts the embedded user-agent can access the user's full authentication credential, not just the OAuth authorization grant that was intended for the app.</p>
<p id="rfc.section.10.19.p.2">In typical web-view-based implementations of embedded user-agents, the host application can record every keystroke entered in the login form to capture usernames and passwords, automatically submit forms to bypass user consent, and copy session cookies and use them to perform authenticated actions as the user.</p>
<p id="rfc.section.10.19.p.3">Even when used by trusted apps belonging to the same party as the authorization server, embedded user-agents violate the principle of least privilege by having access to more powerful credentials than they need, potentially increasing the attack surface.</p>
<p id="rfc.section.10.19.p.4">Encouraging users to enter credentials in an embedded user-agent without the usual address bar and visible certificate validation features that browsers have makes it impossible for the user to know if they are signing in to the legitimate site; even when they are, it trains them that it's OK to enter credentials without validating the site first.</p>
<p id="rfc.section.10.19.p.5">Aside from the security concerns, embedded user-agents do not share the authentication state with other apps or the browser, requiring the user to log in for every authorization request, which is often considered an inferior user experience.</p>
<h1 id="rfc.section.10.20">
<a href="#rfc.section.10.20">10.20.</a> <a href="#other-recommendations" id="other-recommendations">Other Recommendations</a>
</h1>
<p id="rfc.section.10.20.p.1">Authorization servers SHOULD NOT allow clients to influence their <samp>client_id</samp> or <samp>sub</samp> value or any other claim if that can cause confusion with a genuine resource owner (see (#client_impersonating)).</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<h1 id="rfc.section.11.1">
<a href="#rfc.section.11.1">11.1.</a> <a href="#access-token-registry" id="access-token-registry">OAuth Access Token Types Registry</a>
</h1>
<p id="rfc.section.11.1.p.1">This specification establishes the OAuth Access Token Types registry.</p>
<p id="rfc.section.11.1.p.2">Access token types are registered with a Specification Required (<a href="#RFC5226" class="xref">[RFC5226]</a>) after a two-week review period on the oauth-ext-review@ietf.org mailing list, on the advice of one or more Designated Experts.  However, to allow for the allocation of values prior to publication, the Designated Expert(s) may approve registration once they are satisfied that such a specification will be published.</p>
<p id="rfc.section.11.1.p.3">Registration requests must be sent to the oauth-ext-review@ietf.org mailing list for review and comment, with an appropriate subject (e.g., "Request for access token type: example").</p>
<p id="rfc.section.11.1.p.4">Within the review period, the Designated Expert(s) will either approve or deny the registration request, communicating this decision to the review list and IANA.  Denials should include an explanation and, if applicable, suggestions as to how to make the request successful.</p>
<p id="rfc.section.11.1.p.5">IANA must only accept registry updates from the Designated Expert(s) and should direct all requests for registration to the review mailing list.</p>
<h1 id="rfc.section.11.1.1">
<a href="#rfc.section.11.1.1">11.1.1.</a> <a href="#registration-template" id="registration-template">Registration Template</a>
</h1>
<p></p>

<dl>
<dt>Type name:</dt>
<dd style="margin-left: 8">The name requested (e.g., "example").</dd>
<dt>Additional Token Endpoint Response Parameters:</dt>
<dd style="margin-left: 8">Additional response parameters returned together with the "access_token" parameter.  New parameters MUST be separately registered in the OAuth Parameters registry as described by <a href="#parameters-registry" class="xref">Section 11.2</a>.</dd>
<dt>HTTP Authentication Scheme(s):</dt>
<dd style="margin-left: 8">The HTTP authentication scheme name(s), if any, used to authenticate protected resource requests using access tokens of this type.</dd>
<dt>Change controller:</dt>
<dd style="margin-left: 8">For Standards Track RFCs, state "IETF".  For others, give the name of the responsible party.  Other details (e.g., postal address, email address, home page URI) may also be included.</dd>
<dt>Specification document(s):</dt>
<dd style="margin-left: 8">Reference to the document(s) that specify the parameter, preferably including a URI that can be used to retrieve a copy of the document(s).  An indication of the relevant sections may also be included but is not required.</dd>
</dl>
<h1 id="rfc.section.11.1.2">
<a href="#rfc.section.11.1.2">11.1.2.</a> <a href="#initial-registry-contents" id="initial-registry-contents">Initial Registry Contents</a>
</h1>
<p id="rfc.section.11.1.2.p.1">The OAuth Access Token Types registry's initial contents are:</p>
<p></p>

<ul>
<li>Type name: Bearer</li>
<li>Additional Token Endpoint Response Parameters: (none)</li>
<li>HTTP Authentication Scheme(s): Bearer</li>
<li>Change controller: IETF</li>
<li>Specification document(s): OAuth 2.1</li>
</ul>
<h1 id="rfc.section.11.2">
<a href="#rfc.section.11.2">11.2.</a> <a href="#parameters-registry" id="parameters-registry">OAuth Parameters Registry</a>
</h1>
<p id="rfc.section.11.2.p.1">This specification establishes the OAuth Parameters registry.</p>
<p id="rfc.section.11.2.p.2">Additional parameters for inclusion in the authorization endpoint request, the authorization endpoint response, the token endpoint request, or the token endpoint response are registered with a Specification Required (<a href="#RFC5226" class="xref">[RFC5226]</a>) after a two-week review period on the oauth-ext-review@ietf.org mailing list, on the advice of one or more Designated Experts.  However, to allow for the allocation of values prior to publication, the Designated Expert(s) may approve registration once they are satisfied that such a specification will be published.</p>
<p id="rfc.section.11.2.p.3">Registration requests must be sent to the oauth-ext-review@ietf.org mailing list for review and comment, with an appropriate subject (e.g., "Request for parameter: example").</p>
<p id="rfc.section.11.2.p.4">Within the review period, the Designated Expert(s) will either approve or deny the registration request, communicating this decision to the review list and IANA.  Denials should include an explanation and, if applicable, suggestions as to how to make the request successful.</p>
<p id="rfc.section.11.2.p.5">IANA must only accept registry updates from the Designated Expert(s) and should direct all requests for registration to the review mailing list.</p>
<h1 id="rfc.section.11.2.1">
<a href="#rfc.section.11.2.1">11.2.1.</a> <a href="#registration-template-1" id="registration-template-1">Registration Template</a>
</h1>
<p></p>

<dl>
<dt>Parameter name:</dt>
<dd style="margin-left: 8">The name requested (e.g., "example").</dd>
<dt>Parameter usage location:</dt>
<dd style="margin-left: 8">The location(s) where parameter can be used.  The possible locations are authorization request, authorization response, token request, or token response.</dd>
<dt>Change controller:</dt>
<dd style="margin-left: 8">For Standards Track RFCs, state "IETF".  For others, give the name of the responsible party.  Other details (e.g., postal address, email address, home page URI) may also be included.</dd>
<dt>Specification document(s):</dt>
<dd style="margin-left: 8">Reference to the document(s) that specify the parameter, preferably including a URI that can be used to retrieve a copy of the document(s).  An indication of the relevant sections may also be included but is not required.</dd>
</dl>
<h1 id="rfc.section.11.2.2">
<a href="#rfc.section.11.2.2">11.2.2.</a> <a href="#initial-registry-contents-1" id="initial-registry-contents-1">Initial Registry Contents</a>
</h1>
<p id="rfc.section.11.2.2.p.1">The OAuth Parameters registry's initial contents are:</p>
<p></p>

<ul>
<li>Parameter name: client_id</li>
<li>Parameter usage location: authorization request, token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: client_secret</li>
<li>Parameter usage location: token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: response_type</li>
<li>Parameter usage location: authorization request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: redirect_uri</li>
<li>Parameter usage location: authorization request, token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: scope</li>
<li>Parameter usage location: authorization request, authorization response, token request, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: state</li>
<li>Parameter usage location: authorization request, authorization response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: code</li>
<li>Parameter usage location: authorization response, token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: error_description</li>
<li>Parameter usage location: authorization response, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: error_uri</li>
<li>Parameter usage location: authorization response, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: grant_type</li>
<li>Parameter usage location: token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: access_token</li>
<li>Parameter usage location: authorization response, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: token_type</li>
<li>Parameter usage location: authorization response, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: expires_in</li>
<li>Parameter usage location: authorization response, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: username</li>
<li>Parameter usage location: token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: password</li>
<li>Parameter usage location: token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
<li>Parameter name: refresh_token</li>
<li>Parameter usage location: token request, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
</ul>
<h1 id="rfc.section.11.3">
<a href="#rfc.section.11.3">11.3.</a> <a href="#response-types-registry" id="response-types-registry">OAuth Authorization Endpoint Response Types Registry</a>
</h1>
<p id="rfc.section.11.3.p.1">This specification establishes the OAuth Authorization Endpoint Response Types registry.</p>
<p id="rfc.section.11.3.p.2">Additional response types for use with the authorization endpoint are registered with a Specification Required (<a href="#RFC5226" class="xref">[RFC5226]</a>) after a two-week review period on the oauth-ext-review@ietf.org mailing list, on the advice of one or more Designated Experts.  However, to allow for the allocation of values prior to publication, the Designated Expert(s) may approve registration once they are satisfied that such a specification will be published.</p>
<p id="rfc.section.11.3.p.3">Registration requests must be sent to the oauth-ext-review@ietf.org mailing list for review and comment, with an appropriate subject (e.g., "Request for response type: example").</p>
<p id="rfc.section.11.3.p.4">Within the review period, the Designated Expert(s) will either approve or deny the registration request, communicating this decision to the review list and IANA.  Denials should include an explanation and, if applicable, suggestions as to how to make the request successful.</p>
<p id="rfc.section.11.3.p.5">IANA must only accept registry updates from the Designated Expert(s) and should direct all requests for registration to the review mailing list.</p>
<h1 id="rfc.section.11.3.1">
<a href="#rfc.section.11.3.1">11.3.1.</a> <a href="#registration-template-2" id="registration-template-2">Registration Template</a>
</h1>
<p></p>

<dl>
<dt>Response type name:</dt>
<dd style="margin-left: 8">The name requested (e.g., "example").</dd>
<dt>Change controller:</dt>
<dd style="margin-left: 8">For Standards Track RFCs, state "IETF".  For others, give the name of the responsible party.  Other details (e.g., postal address, email address, home page URI) may also be included.</dd>
<dt>Specification document(s):</dt>
<dd style="margin-left: 8">Reference to the document(s) that specify the type, preferably including a URI that can be used to retrieve a copy of the document(s).  An indication of the relevant sections may also be included but is not required.</dd>
</dl>
<h1 id="rfc.section.11.3.2">
<a href="#rfc.section.11.3.2">11.3.2.</a> <a href="#initial-registry-contents-2" id="initial-registry-contents-2">Initial Registry Contents</a>
</h1>
<p id="rfc.section.11.3.2.p.1">The OAuth Authorization Endpoint Response Types registry's initial contents are:</p>
<p></p>

<ul>
<li>Response type name: code</li>
<li>Change controller: IETF</li>
<li>Specification document(s): RFC 6749</li>
</ul>
<h1 id="rfc.section.11.4">
<a href="#rfc.section.11.4">11.4.</a> <a href="#error-registry" id="error-registry">OAuth Extensions Error Registry</a>
</h1>
<p id="rfc.section.11.4.p.1">This specification establishes the OAuth Extensions Error registry.</p>
<p id="rfc.section.11.4.p.2">Additional error codes used together with other protocol extensions (i.e., extension grant types, access token types, or extension parameters) are registered with a Specification Required (<a href="#RFC5226" class="xref">[RFC5226]</a>) after a two-week review period on the oauth-ext-review@ietf.org mailing list, on the advice of one or more Designated Experts.  However, to allow for the allocation of values prior to publication, the Designated Expert(s) may approve registration once they are satisfied that such a specification will be published.</p>
<p id="rfc.section.11.4.p.3">Registration requests must be sent to the oauth-ext-review@ietf.org mailing list for review and comment, with an appropriate subject (e.g., "Request for error code: example").</p>
<p id="rfc.section.11.4.p.4">Within the review period, the Designated Expert(s) will either approve or deny the registration request, communicating this decision to the review list and IANA.  Denials should include an explanation and, if applicable, suggestions as to how to make the request successful.</p>
<p id="rfc.section.11.4.p.5">IANA must only accept registry updates from the Designated Expert(s) and should direct all requests for registration to the review mailing list.</p>
<h1 id="rfc.section.11.4.1">
<a href="#rfc.section.11.4.1">11.4.1.</a> <a href="#registration-template-3" id="registration-template-3">Registration Template</a>
</h1>
<p></p>

<dl>
<dt>Error name:</dt>
<dd style="margin-left: 8">The name requested (e.g., "example").  Values for the error name MUST NOT include characters outside the set %x20-21 / %x23-5B / %x5D-7E.</dd>
<dt>Error usage location:</dt>
<dd style="margin-left: 8">The location(s) where the error can be used.  The possible locations are authorization code grant error response (<a href="#authorization-code-error-response" class="xref">Section 4.1.2.1</a>), token error response (<a href="#access-token-error-response" class="xref">Section 5.2</a>), or resource access error response (<a href="#bearer-token-error-response" class="xref">Section 7.3</a>).</dd>
<dt>Related protocol extension:</dt>
<dd style="margin-left: 8">The name of the extension grant type, access token type, or extension parameter that the error code is used in conjunction with.</dd>
<dt>Change controller:</dt>
<dd style="margin-left: 8">For Standards Track RFCs, state "IETF".  For others, give the name of the responsible party.  Other details (e.g., postal address, email address, home page URI) may also be included.</dd>
<dt>Specification document(s):</dt>
<dd style="margin-left: 8">Reference to the document(s) that specify the error code, preferably including a URI that can be used to retrieve a copy of the document(s).  An indication of the relevant sections may also be included but is not required.</dd>
</dl>
<h1 id="rfc.section.11.4.2">
<a href="#rfc.section.11.4.2">11.4.2.</a> <a href="#initial-registry-contents-3" id="initial-registry-contents-3">Initial Registry Contents</a>
</h1>
<p id="rfc.section.11.4.2.p.1">The OAuth Error registry's initial contents are:</p>
<p></p>

<ul>
<li>Error name: invalid_request</li>
<li>Error usage location: Resource access error response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): OAuth 2.1</li>
<li>Error name: invalid_token</li>
<li>Error usage location: Resource access error response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): OAuth 2.1</li>
<li>Error name: insufficient_scope</li>
<li>Error usage location: Resource access error response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): OAuth 2.1</li>
</ul>
<h1 id="rfc.references">
<a href="#rfc.references">12.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">12.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-oauth-security-topics">[I-D.ietf-oauth-security-topics]</b></td>
<td class="top">
<a>Lodderstedt, T.</a>, <a>Bradley, J.</a>, <a>Labunets, A.</a> and <a>D. Fett</a>, "<a href="https://tools.ietf.org/html/draft-ietf-oauth-security-topics-14">OAuth 2.0 Security Best Current Practice</a>", Internet-Draft draft-ietf-oauth-security-topics-14, February 2020.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2616">[RFC2616]</b></td>
<td class="top">
<a>Fielding, R.</a>, <a>Gettys, J.</a>, <a>Mogul, J.</a>, <a>Frystyk, H.</a>, <a>Masinter, L.</a>, <a>Leach, P.</a> and <a>T. Berners-Lee</a>, "<a href="https://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>", RFC 2616, DOI 10.17487/RFC2616, June 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2617">[RFC2617]</b></td>
<td class="top">
<a>Franks, J.</a>, <a>Hallam-Baker, P.</a>, <a>Hostetler, J.</a>, <a>Lawrence, S.</a>, <a>Leach, P.</a>, <a>Luotonen, A.</a> and <a>L. Stewart</a>, "<a href="https://tools.ietf.org/html/rfc2617">HTTP Authentication: Basic and Digest Access Authentication</a>", RFC 2617, DOI 10.17487/RFC2617, June 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2818">[RFC2818]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>", RFC 2818, DOI 10.17487/RFC2818, May 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="https://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4627">[RFC4627]</b></td>
<td class="top">
<a>Crockford, D.</a>, "<a href="https://tools.ietf.org/html/rfc4627">The application/json Media Type for JavaScript Object Notation (JSON)</a>", RFC 4627, DOI 10.17487/RFC4627, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4949">[RFC4949]</b></td>
<td class="top">
<a>Shirey, R.</a>, "<a href="https://tools.ietf.org/html/rfc4949">Internet Security Glossary, Version 2</a>", FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5226">[RFC5226]</b></td>
<td class="top">
<a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="https://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", RFC 5226, DOI 10.17487/RFC5226, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="https://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6125">[RFC6125]</b></td>
<td class="top">
<a>Saint-Andre, P.</a> and <a>J. Hodges</a>, "<a href="https://tools.ietf.org/html/rfc6125">Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)</a>", RFC 6125, DOI 10.17487/RFC6125, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6749">[RFC6749]</b></td>
<td class="top">
<a>Hardt, D.</a>, "<a href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization Framework</a>", RFC 6749, DOI 10.17487/RFC6749, October 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6750">[RFC6750]</b></td>
<td class="top">
<a>Jones, M.</a> and <a>D. Hardt</a>, "<a href="https://tools.ietf.org/html/rfc6750">The OAuth 2.0 Authorization Framework: Bearer Token Usage</a>", RFC 6750, DOI 10.17487/RFC6750, October 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7595">[RFC7595]</b></td>
<td class="top">
<a>Thaler, D.</a>, <a>Hansen, T.</a> and <a>T. Hardie</a>, "<a href="https://tools.ietf.org/html/rfc7595">Guidelines and Registration Procedures for URI Schemes</a>", BCP 35, RFC 7595, DOI 10.17487/RFC7595, June 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8252">[RFC8252]</b></td>
<td class="top">
<a>Denniss, W.</a> and <a>J. Bradley</a>, "<a href="https://tools.ietf.org/html/rfc8252">OAuth 2.0 for Native Apps</a>", BCP 212, RFC 8252, DOI 10.17487/RFC8252, October 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8446">[RFC8446]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/rfc8446">The Transport Layer Security (TLS) Protocol Version 1.3</a>", RFC 8446, DOI 10.17487/RFC8446, August 2018.</td>
</tr>
<tr>
<td class="reference"><b id="USASCII">[USASCII]</b></td>
<td class="top">
<a>Institute, A.</a>, "<a>Coded Character Set -- 7-bit American Standard Code for Information Interchange, ANSI X3.4</a>", 1986.</td>
</tr>
<tr>
<td class="reference"><b id="W3C.REC-html401-19991224">[W3C.REC-html401-19991224]</b></td>
<td class="top">
<a>Raggett, D.</a>, <a>Hors, A.</a> and <a>I. Jacobs</a>, "<a href="http://www.w3.org/TR/1999/REC-html401-19991224">HTML 4.01 Specification</a>", World Wide Web Consortium Recommendation REC-html401-19991224, December 1999.</td>
</tr>
<tr>
<td class="reference"><b id="W3C.REC-xml-20081126">[W3C.REC-xml-20081126]</b></td>
<td class="top">
<a>Bray, T.</a>, <a>Paoli, J.</a>, <a>Sperberg-McQueen, M.</a>, <a>Maler, E.</a> and <a>F. Yergeau</a>, "<a href="http://www.w3.org/TR/2008/REC-xml-20081126">Extensible Markup Language (XML) 1.0 (Fifth Edition)</a>", World Wide Web Consortium Recommendation REC-xml-20081126, November 2008.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">12.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="CSP-2">[CSP-2]</b></td>
<td class="top">"<a>Content Security Policy Level 2</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="HTTP-AUTH">[HTTP-AUTH]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a>Hypertext Transfer Protocol (HTTP/1.1): Authentication</a>", October 2012.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.bradley-oauth-jwt-encoded-state">[I-D.bradley-oauth-jwt-encoded-state]</b></td>
<td class="top">
<a>Bradley, J.</a>, <a>Lodderstedt, T.</a> and <a>H. Zandbelt</a>, "<a href="https://tools.ietf.org/html/draft-bradley-oauth-jwt-encoded-state-09">Encoding claims in the OAuth 2 state parameter using a JWT</a>", Internet-Draft draft-bradley-oauth-jwt-encoded-state-09, November 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-oauth-browser-based-apps">[I-D.ietf-oauth-browser-based-apps]</b></td>
<td class="top">
<a>Parecki, A.</a> and <a>D. Waite</a>, "<a href="https://tools.ietf.org/html/draft-ietf-oauth-browser-based-apps-05">OAuth 2.0 for Browser-Based Apps</a>", Internet-Draft draft-ietf-oauth-browser-based-apps-05, February 2020.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-oauth-rar">[I-D.ietf-oauth-rar]</b></td>
<td class="top">
<a>Lodderstedt, T.</a>, <a>Richer, J.</a> and <a>B. Campbell</a>, "<a href="https://tools.ietf.org/html/draft-ietf-oauth-rar-01">OAuth 2.0 Rich Authorization Requests</a>", Internet-Draft draft-ietf-oauth-rar-01, February 2020.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-oauth-resource-indicators">[I-D.ietf-oauth-resource-indicators]</b></td>
<td class="top">
<a>Campbell, B.</a>, <a>Bradley, J.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/draft-ietf-oauth-resource-indicators-08">Resource Indicators for OAuth 2.0</a>", Internet-Draft draft-ietf-oauth-resource-indicators-08, September 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-oauth-token-binding">[I-D.ietf-oauth-token-binding]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Campbell, B.</a>, <a>Bradley, J.</a> and <a>W. Denniss</a>, "<a href="https://tools.ietf.org/html/draft-ietf-oauth-token-binding-08">OAuth 2.0 Token Binding</a>", Internet-Draft draft-ietf-oauth-token-binding-08, October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="NIST800-63">[NIST800-63]</b></td>
<td class="top">
<a>Burr, W.</a>, <a>Dodson, D.</a>, <a>Newton, E.</a>, <a>Perlner, R.</a>, <a>Polk, T.</a>, <a>Gupta, S.</a> and <a>E. Nabbus</a>, "<a>NIST Special Publication 800-63-1, INFORMATION SECURITY</a>", December 2011.</td>
</tr>
<tr>
<td class="reference"><b id="OMAP">[OMAP]</b></td>
<td class="top">
<a>Huff, J.</a>, <a>Schlacht, D.</a>, <a>Nadalin, A.</a>, <a>Simmons, J.</a>, <a>Rosenberg, P.</a>, <a>Madsen, P.</a>, <a>Ace, T.</a>, <a>Rickelton-Abdi, C.</a> and <a>B. Boyer</a>, "<a>Online Multimedia Authorization Protocol: An Industry Standard for Authorized Access to Internet Multimedia Resources</a>", April 2012.</td>
</tr>
<tr>
<td class="reference"><b id="OpenID">[OpenID]</b></td>
<td class="top">"<a>OpenID Connect</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="OpenID.Messages">[OpenID.Messages]</b></td>
<td class="top">
<a>Sakimura, N.</a>, <a>Bradley, J.</a>, <a>Jones, M.</a>, <a>de Medeiros, B.</a>, <a>Mortimore, C.</a> and <a>E. Jay</a>, "<a>OpenID Connect Messages 1.0</a>", June 2012.</td>
</tr>
<tr>
<td class="reference"><b id="owasp_redir">[owasp_redir]</b></td>
<td class="top">"<a>OWASP Cheat Sheet Series - Unvalidated Redirects and Forwards</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="RFC5849">[RFC5849]</b></td>
<td class="top">
<a>Hammer-Lahav, E.</a>, "<a href="https://tools.ietf.org/html/rfc5849">The OAuth 1.0 Protocol</a>", RFC 5849, DOI 10.17487/RFC5849, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6265">[RFC6265]</b></td>
<td class="top">
<a>Barth, A.</a>, "<a href="https://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>", RFC 6265, DOI 10.17487/RFC6265, April 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6819">[RFC6819]</b></td>
<td class="top">
<a>Lodderstedt, T.</a>, <a>McGloin, M.</a> and <a>P. Hunt</a>, "<a href="https://tools.ietf.org/html/rfc6819">OAuth 2.0 Threat Model and Security Considerations</a>", RFC 6819, DOI 10.17487/RFC6819, January 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7230">[RFC7230]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7522">[RFC7522]</b></td>
<td class="top">
<a>Campbell, B.</a>, <a>Mortimore, C.</a> and <a>M. Jones</a>, "<a href="https://tools.ietf.org/html/rfc7522">Security Assertion Markup Language (SAML) 2.0 Profile for OAuth 2.0 Client Authentication and Authorization Grants</a>", RFC 7522, DOI 10.17487/RFC7522, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7591">[RFC7591]</b></td>
<td class="top">
<a>Richer, J.</a>, <a>Jones, M.</a>, <a>Bradley, J.</a>, <a>Machulak, M.</a> and <a>P. Hunt</a>, "<a href="https://tools.ietf.org/html/rfc7591">OAuth 2.0 Dynamic Client Registration Protocol</a>", RFC 7591, DOI 10.17487/RFC7591, July 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7636">[RFC7636]</b></td>
<td class="top">
<a>Sakimura, N.</a>, <a>Bradley, J.</a> and <a>N. Agarwal</a>, "<a href="https://tools.ietf.org/html/rfc7636">Proof Key for Code Exchange by OAuth Public Clients</a>", RFC 7636, DOI 10.17487/RFC7636, September 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8414">[RFC8414]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Sakimura, N.</a> and <a>J. Bradley</a>, "<a href="https://tools.ietf.org/html/rfc8414">OAuth 2.0 Authorization Server Metadata</a>", RFC 8414, DOI 10.17487/RFC8414, June 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8418">[RFC8418]</b></td>
<td class="top">
<a>Housley, R.</a>, "<a href="https://tools.ietf.org/html/rfc8418">Use of the Elliptic Curve Diffie-Hellman Key Agreement Algorithm with X25519 and X448 in the Cryptographic Message Syntax (CMS)</a>", RFC 8418, DOI 10.17487/RFC8418, August 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8705">[RFC8705]</b></td>
<td class="top">
<a>Campbell, B.</a>, <a>Bradley, J.</a>, <a>Sakimura, N.</a> and <a>T. Lodderstedt</a>, "<a href="https://tools.ietf.org/html/rfc8705">OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens</a>", RFC 8705, DOI 10.17487/RFC8705, February 2020.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8707">[RFC8707]</b></td>
<td class="top">
<a>Campbell, B.</a>, <a>Bradley, J.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/rfc8707">Resource Indicators for OAuth 2.0</a>", RFC 8707, DOI 10.17487/RFC8707, February 2020.</td>
</tr>
<tr>
<td class="reference"><b id="webauthn">[webauthn]</b></td>
<td class="top">
<a>Balfanz, D.</a>, <a>Czeskis, A.</a>, <a>Hodges, J.</a>, <a>Jones, J.</a>, <a>Jones, M.</a>, <a>Kumar, A.</a>, <a>Liao, A.</a>, <a>Lindemann, R.</a> and <a>E. Lundberg</a>, "<a>Web Authentication: An API for accessing Public Key Credentials Level 1</a>", March 2019.</td>
</tr>
<tr>
<td class="reference"><b id="webcrypto">[webcrypto]</b></td>
<td class="top">
<a>Watson, M.</a>, "<a>Web Cryptography API</a>", January 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#augmented-backus-naur-form-abnf-syntax" id="augmented-backus-naur-form-abnf-syntax">Augmented Backus-Naur Form (ABNF) Syntax</a>
</h1>
<p id="rfc.section.A.p.1">This section provides Augmented Backus-Naur Form (ABNF) syntax descriptions for the elements defined in this specification using the notation of <a href="#RFC5234" class="xref">[RFC5234]</a>.  The ABNF below is defined in terms of Unicode code points <a href="#W3C.REC-xml-20081126" class="xref">[W3C.REC-xml-20081126]</a>; these characters are typically encoded in UTF-8.  Elements are presented in the order first defined.</p>
<p id="rfc.section.A.p.2">Some of the definitions that follow use the "URI-reference" definition from <a href="#RFC3986" class="xref">[RFC3986]</a>.</p>
<p id="rfc.section.A.p.3">Some of the definitions that follow use these common definitions:</p>
<pre>
VSCHAR     = %x20-7E
NQCHAR     = %x21 / %x23-5B / %x5D-7E
NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E
UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /
                    %xE000-FFFD / %x10000-10FFFF
</pre>
<p id="rfc.section.A.p.4">(The UNICODECHARNOCRLF definition is based upon the Char definition in Section 2.2 of <a href="#W3C.REC-xml-20081126" class="xref">[W3C.REC-xml-20081126]</a>, but omitting the Carriage Return and Linefeed characters.)</p>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#clientid-syntax" id="clientid-syntax">"client_id" Syntax</a>
</h1>
<p id="rfc.section.A.1.p.1">The "client_id" element is defined in <a href="#client-password" class="xref">Section 2.3.1</a>:</p>
<pre>
client-id     = *VSCHAR
</pre>
<h1 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#clientsecret-syntax" id="clientsecret-syntax">"client_secret" Syntax</a>
</h1>
<p id="rfc.section.A.2.p.1">The "client_secret" element is defined in <a href="#client-password" class="xref">Section 2.3.1</a>:</p>
<pre>
client-secret = *VSCHAR
</pre>
<h1 id="rfc.appendix.A.3">
<a href="#rfc.appendix.A.3">A.3.</a> <a href="#responsetype-syntax" id="responsetype-syntax">"response_type" Syntax</a>
</h1>
<p id="rfc.section.A.3.p.1">The "response_type" element is defined in <a href="#response-type" class="xref">Section 3.1.1</a> and <a href="#new-response-types" class="xref">Section 8.4</a>:</p>
<pre>
response-type = response-name *( SP response-name )
response-name = 1*response-char
response-char = "_" / DIGIT / ALPHA
</pre>
<h1 id="rfc.appendix.A.4">
<a href="#rfc.appendix.A.4">A.4.</a> <a href="#scope-syntax" id="scope-syntax">"scope" Syntax</a>
</h1>
<p id="rfc.section.A.4.p.1">The "scope" element is defined in <a href="#access-token-scope" class="xref">Section 3.3</a>:</p>
<pre>
 scope       = scope-token *( SP scope-token )
 scope-token = 1*NQCHAR
</pre>
<h1 id="rfc.appendix.A.5">
<a href="#rfc.appendix.A.5">A.5.</a> <a href="#state-syntax" id="state-syntax">"state" Syntax</a>
</h1>
<p id="rfc.section.A.5.p.1">The "state" element is defined in <a href="#authorization-request" class="xref">Section 4.1.1</a>, <a href="#authorization-response" class="xref">Section 4.1.2</a>, and <a href="#authorization-code-error-response" class="xref">Section 4.1.2.1</a>:</p>
<pre>
 state      = 1*VSCHAR
</pre>
<h1 id="rfc.appendix.A.6">
<a href="#rfc.appendix.A.6">A.6.</a> <a href="#redirecturi-syntax" id="redirecturi-syntax">"redirect_uri" Syntax</a>
</h1>
<p id="rfc.section.A.6.p.1">The "redirect_uri" element is defined in <a href="#authorization-request" class="xref">Section 4.1.1</a>, and <a href="#access-token-request" class="xref">Section 4.1.3</a>:</p>
<pre>
 redirect-uri      = URI-reference
</pre>
<h1 id="rfc.appendix.A.7">
<a href="#rfc.appendix.A.7">A.7.</a> <a href="#error-syntax" id="error-syntax">"error" Syntax</a>
</h1>
<p id="rfc.section.A.7.p.1">The "error" element is defined in Sections <a href="#authorization-code-error-response" class="xref">Section 4.1.2.1</a>, <a href="#access-token-error-response" class="xref">Section 5.2</a>, 7.2, and 8.5:</p>
<pre>
 error             = 1*NQSCHAR
</pre>
<h1 id="rfc.appendix.A.8">
<a href="#rfc.appendix.A.8">A.8.</a> <a href="#errordescription-syntax" id="errordescription-syntax">"error_description" Syntax</a>
</h1>
<p id="rfc.section.A.8.p.1">The "error_description" element is defined in Sections <a href="#authorization-code-error-response" class="xref">Section 4.1.2.1</a>, <a href="#access-token-error-response" class="xref">Section 5.2</a>, and <a href="#bearer-token-error-response" class="xref">Section 7.3</a>:</p>
<pre>
 error-description = 1*NQSCHAR
</pre>
<h1 id="rfc.appendix.A.9">
<a href="#rfc.appendix.A.9">A.9.</a> <a href="#erroruri-syntax" id="erroruri-syntax">"error_uri" Syntax</a>
</h1>
<p id="rfc.section.A.9.p.1">The "error_uri" element is defined in Sections <a href="#authorization-code-error-response" class="xref">Section 4.1.2.1</a>, <a href="#access-token-error-response" class="xref">Section 5.2</a>, and 7.2:</p>
<pre>
 error-uri         = URI-reference
</pre>
<h1 id="rfc.appendix.A.10">
<a href="#rfc.appendix.A.10">A.10.</a> <a href="#granttype-syntax" id="granttype-syntax">"grant_type" Syntax</a>
</h1>
<p id="rfc.section.A.10.p.1">The "grant_type" element is defined in Sections <a href="#access-token-request" class="xref">Section 4.1.3</a>, <a href="#access-token-response" class="xref">Section 4.2.3</a>, <a href="#client-credentials-access-token-request" class="xref">Section 4.2.2</a>, <a href="#extension-grants" class="xref">Section 4.3</a>, and <a href="#refreshing-an-access-token" class="xref">Section 6</a>:</p>
<pre>
 grant-type = grant-name / URI-reference
 grant-name = 1*name-char
 name-char  = "-" / "." / "_" / DIGIT / ALPHA
</pre>
<h1 id="rfc.appendix.A.11">
<a href="#rfc.appendix.A.11">A.11.</a> <a href="#code-syntax" id="code-syntax">"code" Syntax</a>
</h1>
<p id="rfc.section.A.11.p.1">The "code" element is defined in <a href="#access-token-request" class="xref">Section 4.1.3</a>:</p>
<pre>
 code       = 1*VSCHAR
</pre>
<h1 id="rfc.appendix.A.12">
<a href="#rfc.appendix.A.12">A.12.</a> <a href="#accesstoken-syntax" id="accesstoken-syntax">"access_token" Syntax</a>
</h1>
<p id="rfc.section.A.12.p.1">The "access_token" element is defined in <a href="#access-token-response" class="xref">Section 4.2.3</a> and <a href="#access-token-successful-response" class="xref">Section 5.1</a>:</p>
<pre>
 access-token = 1*VSCHAR
</pre>
<h1 id="rfc.appendix.A.13">
<a href="#rfc.appendix.A.13">A.13.</a> <a href="#tokentype-syntax" id="tokentype-syntax">"token_type" Syntax</a>
</h1>
<p id="rfc.section.A.13.p.1">The "token_type" element is defined in <a href="#access-token-successful-response" class="xref">Section 5.1</a>, and <a href="#defining-access-token-types" class="xref">Section 8.1</a>:</p>
<pre>
 token-type = type-name / URI-reference
 type-name  = 1*name-char
 name-char  = "-" / "." / "_" / DIGIT / ALPHA
</pre>
<h1 id="rfc.appendix.A.14">
<a href="#rfc.appendix.A.14">A.14.</a> <a href="#expiresin-syntax" id="expiresin-syntax">"expires_in" Syntax</a>
</h1>
<p id="rfc.section.A.14.p.1">The "expires_in" element is defined in <a href="#access-token-successful-response" class="xref">Section 5.1</a>:</p>
<pre>
 expires-in = 1*DIGIT
</pre>
<h1 id="rfc.appendix.A.15">
<a href="#rfc.appendix.A.15">A.15.</a> <a href="#refreshtoken-syntax" id="refreshtoken-syntax">"refresh_token" Syntax</a>
</h1>
<p id="rfc.section.A.15.p.1">The "refresh_token" element is defined in <a href="#access-token-successful-response" class="xref">Section 5.1</a> and <a href="#refreshing-an-access-token" class="xref">Section 6</a>:</p>
<pre>
 refresh-token = 1*VSCHAR
</pre>
<h1 id="rfc.appendix.A.16">
<a href="#rfc.appendix.A.16">A.16.</a> <a href="#endpoint-parameter-syntax" id="endpoint-parameter-syntax">Endpoint Parameter Syntax</a>
</h1>
<p id="rfc.section.A.16.p.1">The syntax for new endpoint parameters is defined in <a href="#defining-new-endpoint-parameters" class="xref">Section 8.2</a>:</p>
<pre>
 param-name = 1*name-char
 name-char  = "-" / "." / "_" / DIGIT / ALPHA
</pre>
<h1 id="rfc.appendix.A.17">
<a href="#rfc.appendix.A.17">A.17.</a> <a href="#codeverifier-syntax" id="codeverifier-syntax">"code_verifier" Syntax</a>
</h1>
<p id="rfc.section.A.17.p.1">ABNF for "code_verifier" is as follows.</p>
<pre>
code-verifier = 43*128unreserved
unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
ALPHA = %x41-5A / %x61-7A
DIGIT = %x30-39
</pre>
<h1 id="rfc.appendix.A.18">
<a href="#rfc.appendix.A.18">A.18.</a> <a href="#codechallenge-syntax" id="codechallenge-syntax">"code_challenge" Syntax</a>
</h1>
<p id="rfc.section.A.18.p.1">ABNF for "code_challenge" is as follows.</p>
<pre>
code-challenge = 43*128unreserved
unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
ALPHA = %x41-5A / %x61-7A
DIGIT = %x30-39
</pre>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#use-of-applicationx-www-form-urlencoded-media-type" id="use-of-applicationx-www-form-urlencoded-media-type">Use of application/x-www-form-urlencoded Media Type</a>
</h1>
<p id="rfc.section.B.p.1">At the time of publication of this specification, the "application/x-www-form-urlencoded" media type was defined in Section 17.13.4 of <a href="#W3C.REC-html401-19991224" class="xref">[W3C.REC-html401-19991224]</a> but not registered in the IANA MIME Media Types registry (<a href="http://www.iana.org/assignments/media-types">http://www.iana.org/assignments/media-types</a>).  Furthermore, that definition is incomplete, as it does not consider non-US-ASCII characters.</p>
<p id="rfc.section.B.p.2">To address this shortcoming when generating payloads using this media type, names and values MUST be encoded using the UTF-8 character encoding scheme <a href="#RFC3629" class="xref">[RFC3629]</a> first; the resulting octet sequence then needs to be further encoded using the escaping rules defined in <a href="#W3C.REC-html401-19991224" class="xref">[W3C.REC-html401-19991224]</a>.</p>
<p id="rfc.section.B.p.3">When parsing data from a payload using this media type, the names and values resulting from reversing the name/value encoding consequently need to be treated as octet sequences, to be decoded using the UTF-8 character encoding scheme.</p>
<p id="rfc.section.B.p.4">For example, the value consisting of the six Unicode code points (1) U+0020 (SPACE), (2) U+0025 (PERCENT SIGN), (3) U+0026 (AMPERSAND), (4) U+002B (PLUS SIGN), (5) U+00A3 (POUND SIGN), and (6) U+20AC (EURO SIGN) would be encoded into the octet sequence below (using hexadecimal notation):</p>
<pre>
20 25 26 2B C2 A3 E2 82 AC
</pre>
<p id="rfc.section.B.p.5">and then represented in the payload as:</p>
<pre>
+%25%26%2B%C2%A3%E2%82%AC
</pre>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.C.p.1">TBD</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Aaron Parecki</span> 
	  <span class="n hidden">
		<span class="family-name">Parecki</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:aaron@parecki.com">aaron@parecki.com</a></span>

<span class="vcardline">URI: <a href="https://aaronparecki.com">https://aaronparecki.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Dick Hardt</span> 
	  <span class="n hidden">
		<span class="family-name">Hardt</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:dick.hardt@gmail.com">dick.hardt@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Torsten Lodderstedt</span> 
	  <span class="n hidden">
		<span class="family-name">Lodderstedt</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:torsten@lodderstedt.net">torsten@lodderstedt.net</a></span>

  </address>
</div>

</body>
</html>
